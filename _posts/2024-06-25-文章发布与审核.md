---
layout: post
title: 04 文章发布与审核
date: 2024-06-26 22:20 +0800
categories: [Blogging, TJU-news]
author: <author_id>
---

## 文章数据流

如下图所示，文章发布主要分为以下几个步骤：

1. 在 `Media` 微服务发布文章，存入数据库中；异步调用文章审核方法；
2. 文章审核成功后，调用 `Article` 微服务保存文章，APP 端可以查看文章；

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240625164534731.png" alt="image-20240625164534731" style="zoom:40%;" />





## App 端文章保存

### 表结构

`ap_article` 文章信息表

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627165034466.png" alt="image-20240627165034466" style="zoom:45%;" />

`ap_article_config`  文章配置表

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627165142399.png" alt="image-20240627165142399" style="zoom:45%;" />

`ap_article_content` 文章内容表

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627165224548.png" alt="image-20240627165224548" style="zoom:45%;" />

### 分布式 id

随着业务的增长，文章表可能要占用很大的物理存储空间，为了解决该问题，后期使用数据库分片技术。将一个数据库进行拆分，通过数据库中间件连接。如果数据库中该表选用 ID 自增策略，则可能产生重复的 ID，此时应该使用分布式 ID 生成策略来生成 ID。

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627165341338.png" alt="image-20240627165341338" style="zoom:40%;" />

`snowflake` 是 `Twitter` 开源的分布式 ID 生成算法，结果是一个 long 型的 ID。其核心思想是：使用 41bit 作为毫秒数，10bit 作为机器的 ID（5个bit是数据中心，5个bit的机器ID），12bit 作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是 0。

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627165448306.png" alt="image-20240627165448306" style="zoom:45%;" />

文章端相关的表都使用雪花算法生成 id，包括 `ap_article`、 `ap_article_config`、 `ap_article_content`

`mybatis-plus` 已经集成了雪花算法，完成以下两步即可在项目中集成雪花算法

第一：在实体类中的 `id` 上加入如下配置，指定类型为 `id_worker`

```java
@TableId(value = "id",type = IdType.ID_WORKER)
private Long id;
```

第二：在 Nacos 中 `leadnews-article` 配置数据中心 `id` 和机器 `id`

```yaml
mybatis-plus:
  mapper-locations: classpath*:mapper/*.xml
  # 设置别名包扫描路径，通过该属性可以给包中的类注册别名
  type-aliases-package: com.shawen.model.article.pojos
  global-config:
    datacenter-id: 1
    workerId: 1
```

`datacenter-id`：数据中心 `id` (取值范围：0-31)

`workerId`：机器 `id` (取值范围：0-31)

 

### 思路分析

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627170156145.png" alt="image-20240627170156145" style="zoom:40%;" />

在文章审核成功以后需要在 `app` 的 `article` 库中新增文章数据

1. 保存文章信息 `ap_article`

2. 保存文章配置信息 `ap_article_config`

3. 保存文章内容 `ap_article_content`

### feign 接口

|          |       **说明**       |
| :------: | :------------------: |
| 接口路径 | /api/v1/article/save |
| 请求方式 |         POST         |
|   参数   |      ArticleDto      |
| 响应结果 |    ResponseResult    |

**ArticleDto：**

```java
@Data
public class ArticleDto  extends ApArticle {
    /**
     * 文章内容
     */
    private String content;
}
```



**ResponseResult：**

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627170847298.png" alt="image-20240627170847298" style="zoom:50%;" />

### 代码实现

**①：在 `TJU-campus-feign-api` 中新增接口；**

第一：先导入feign的依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

第二：定义文章端的接口

```java
@FeignClient(value = "leadnews-article")
public interface IArticleClient {

    @PostMapping("/api/v1/article/save")
    public ResponseResult saveArticle(@RequestBody ArticleDto dto) ;
}
```

**②：在 TJU-campus-article 中实现该方法**

```java
package com.shawen.article.feign;

@RestController
public class ArticleClient implements IArticleClient {

    @Autowired
    private ApArticleService apArticleService;

    @Override
    @PostMapping("/api/v1/article/save")
    public ResponseResult saveArticle(@RequestBody ArticleDto dto) {
        return apArticleService.saveArticle(dto);
    }

}
```

在 `ApArticleService` 中新增方法，以及对应的实现类

```java
public interface ApArticleService extends IService<ApArticle> {

    /**
     * 保存app端相关文章
     * @param dto
     * @return
     */
    ResponseResult saveArticle(ArticleDto dto) ;
}
```



```java
@Service
@Transactional
@Slf4j
public class ApArticleServiceImpl  extends ServiceImpl<ApArticleMapper, ApArticle> implements ApArticleService {

		@Autowired
    private ApArticleConfigMapper apArticleConfigMapper;

    @Autowired
    private ApArticleContentMapper apArticleContentMapper;

    /**
     * 保存app端相关文章
     * @param dto
     * @return
     */
    @Override
    public ResponseResult saveArticle(ArticleDto dto) {
        //1.检查参数
        if(dto == null){
            return ResponseResult.errorResult(AppHttpCodeEnum.PARAM_INVALID);
        }

        ApArticle apArticle = new ApArticle();
        BeanUtils.copyProperties(dto,apArticle);

        //2.判断是否存在id
        if(dto.getId() == null){
            //2.1 不存在id  保存  文章  文章配置  文章内容

            //保存文章
            save(apArticle);

            //保存配置
            ApArticleConfig apArticleConfig = new ApArticleConfig(apArticle.getId());
            apArticleConfigMapper.insert(apArticleConfig);

            //保存 文章内容
            ApArticleContent apArticleContent = new ApArticleContent();
            apArticleContent.setArticleId(apArticle.getId());
            apArticleContent.setContent(dto.getContent());
            apArticleContentMapper.insert(apArticleContent);

        }else {
            //2.2 存在id   修改  文章  文章内容

            //修改  文章
            updateById(apArticle);

            //修改文章内容
            ApArticleContent apArticleContent = apArticleContentMapper.selectOne(Wrappers.<ApArticleContent>lambdaQuery().eq(ApArticleContent::getArticleId, dto.getId()));
            apArticleContent.setContent(dto.getContent());
            apArticleContentMapper.updateById(apArticleContent);
        }


        //3.结果返回  文章的id
        return ResponseResult.okResult(apArticle.getId());
    }
}
```



## 自媒体文章自动审核流程

### 表结构

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627194624026.png" alt="image-20240627194624026" style="zoom:40%;" />

`status` 字段：0 草稿  1 待审核  2 审核失败  3 人工审核  4 人工审核通过  8 审核通过（待发布） 9 已发布

### 调用第三方接口审核



<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240625204545996.png" alt="image-20240625204545996" style="zoom:35%;" />



1. 自媒体端发布文章后，借助第三方接口审核文章的内容（文本内容和图片）；
2. 图片存储在 `MinIO` 中，需先下载再审核；
3. 审核失败，则需要修改自媒体文章的状态，`status: 2`  审核失败   `status: 3`  转到人工审核；
4. 审核成功，则需要在文章微服务中创建 `app` 端需要的文章；



### feign远程调用服务降级处理

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240625211932193.png" alt="image-20240625211932193" style="zoom:40%;" />

- 服务降级是服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用；
- 确保服务不会崩溃服务降级虽然会导致请求失败，但是不会导致阻塞。



**实现步骤：**

①：在 TJU-campus-feign-api 编写降级逻辑

```java
@Component
public class IArticleClientFallback implements IArticleClient {
    @Override
    public ResponseResult saveArticle(ArticleDto dto)  {
        return ResponseResult.errorResult(AppHttpCodeEnum.SERVER_ERROR,"获取数据失败");
    }
}
```

在自媒体微服务中添加类，扫描降级代码类的包

```java
@Configuration
@ComponentScan("com.shawen.apis.article.fallback")
public class InitConfig {
}
```

②：远程接口中指向降级代码

```java
@FeignClient(value = "leadnews-article",fallback = IArticleClientFallback.class)
public interface IArticleClient {

    @PostMapping("/api/v1/article/save")
    public ResponseResult saveArticle(@RequestBody ArticleDto dto) ;
}
```

③：客户端开启降级 TJU-campus-wemedia

在 `wemedia` 的 `nacos` 配置中心里添加如下内容，开启服务降级，也可以指定服务响应的超时的时间

```yaml
feign:
  # 开启feign对hystrix熔断降级的支持
  hystrix:
    enabled: true
  # 修改调用超时时间
  client:
    config:
      default:
        connectTimeout: 2000
        readTimeout: 2000
```

④：测试

在 `ApArticleServiceImpl` 类中 `saveArticle` 方法添加代码

```java
try {
    Thread.sleep(3000);
} catch (InterruptedException e) {
    e.printStackTrace();
}
```



## 发布文章提交审核集成

### 同步调用与异步调用

同步：就是在发出一个调用时，在没有得到结果之前， 该调用就不返回（实时处理）

异步：调用在发出之后，这个调用就直接返回了，没有返回结果（分时处理）

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627200606337.png" alt="image-20240627200606337" style="zoom:50%;" />

### 代码实现

①：在自动审核的方法上加上 `@Async` 注解（标明要异步调用）

```java
@Override
@Async  //标明当前方法是一个异步方法
public void autoScanWmNews(Integer id) {
	//代码略
}
```

②：在文章发布成功后调用审核的方法

```java
@Autowired
private WmNewsAutoScanService wmNewsAutoScanService;

/**
 * 发布修改文章或保存为草稿
 * @param dto
 * @return
 */
@Override
public ResponseResult submitNews(WmNewsDto dto) {

    //代码略

    //审核文章
    wmNewsAutoScanService.autoScanWmNews(wmNews.getId());

    return ResponseResult.okResult(AppHttpCodeEnum.SUCCESS);

}
```

③：在自媒体引导类中使用 `@EnableAsync` 注解开启异步调用

```java
@SpringBootApplication
@EnableDiscoveryClient
@MapperScan("com.shawen.wemedia.mapper")
@EnableFeignClients(basePackages = "com.shawen.apis.article")
@EnableAsync  //开启异步调用
public class WemediaApplication {

    public static void main(String[] args) {
        SpringApplication.run(WemediaApplication.class,args);
    }
}
```



### 综合测试

**服务启动列表：**

1. nacos 服务端
2. article 微服务
3. wemedia 微服务
4. 启动 wemedia 网关微服务
5. 启动前端系统 wemedia



**测试情况列表：**

1. 自媒体前端发布一篇正常的文章

   审核成功后，app 端的 article 相关数据是否可以正常保存，自媒体文章状态和 app 端文章 id 是否回显

2. 自媒体前端发布一篇包含敏感词的文章

   正常是审核失败， wm_news 表 中的状态是否改变，成功和失败原因正常保存

3. 自媒体前端发布一篇包含敏感图片的文章

   正常是审核失败， wm_news 表中的状态是否改变，成功和失败原因正常保存





## 自定义敏感词过滤

对于第三方接口不能审核通过的敏感词，需要自己维护一套敏感词，在文章审核的时候，需要验证文章是否包含这些敏感词。

**技术选型：**

|        **方案**        |           **说明**           |
| :--------------------: | :--------------------------: |
|     数据库模糊查询     |           效率太低           |
| String.indexOf("")查找 |   数据库量大的话也是比较慢   |
|        全文检索        |          分词再匹配          |
|        DFA算法         | 确定有穷自动机(一种数据结构) |

### `DFA` 实现原理

- `DFA`全称为：**Deterministic Finite Automaton**，即 **确定有穷自动机**。

- 存储：一次性的把所有的敏感词存储到了多个 `map` 中，就是下图表示这种结构；

- 敏感词：冰毒、大麻、大坏蛋。

`isEnd —> 1` 敏感词结尾；	`isEnd —> 0` 不是敏感词结尾；

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240625205701594.png" alt="image-20240625205701594" style="zoom:45%;" />          <img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240625205723013.png" alt="image-20240625205723013" style="zoom:25%;" />



检索流程如下图所示：

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240625210054070.png" alt="image-20240625210054070" style="zoom:35%;" />

### 敏感词表结构

在 `leadnews_wemedia` 数据库中创建敏感词表

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627212541153.png" alt="image-20240627212541153" style="zoom:45%;" />

对应的实体：

```java
@Data
@TableName("wm_sensitive")
public class WmSensitive implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 主键
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    /**
     * 敏感词
     */
    @TableField("sensitives")
    private String sensitives;

    /**
     * 创建时间
     */
    @TableField("created_time")
    private Date createdTime;

}
```

### 实现代码

mapper：

```java
@Mapper
public interface WmSensitiveMapper extends BaseMapper<WmSensitive> {
}
```



在文章审核的代码中添加自管理敏感词审核

第一：在 `WmNewsAutoScanServiceImpl` 中的 `autoScanWmNews` 方法上添加如下代码

```java
//从内容中提取纯文本内容和图片
//.....省略

//自管理的敏感词过滤
boolean isSensitive = handleSensitiveScan((String) textAndImages.get("content"), wmNews);
if(!isSensitive) return;

//2.审核文本内容  阿里云接口
//.....省略
```

在 该 `Impl` 中新增自管理敏感词审核代码

```java
    @Autowired
    private WmSensitiveMapper wmSensitiveMapper;

    /**
     * 自管理的敏感词审核
     * @param content
     * @param wmNews
     * @return
     */
    private boolean handleSensitiveScan(String content, WmNews wmNews) {

        boolean flag = true;

        //获取所有的敏感词
        List<WmSensitive> wmSensitives = wmSensitiveMapper.selectList(Wrappers.<WmSensitive>lambdaQuery().select(WmSensitive::getSensitives));
        List<String> sensitiveList = wmSensitives.stream().map(WmSensitive::getSensitives).collect(Collectors.toList());

        //初始化敏感词库
        SensitiveWordUtil.initMap(sensitiveList);

        //查看文章中是否包含敏感词
        Map<String, Integer> map = SensitiveWordUtil.matchWords(content);
        if(map.size() >0){
            updateWmNews(wmNews,(short) 2,"当前文章中存在违规内容"+map);
            flag = false;
        }

        return flag;
    }

```



## 文章详情-静态文件生成

文章端创建 app 相关文章时，生成文章详情静态页上传到 MinIO 中：

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240625211000830.png" alt="image-20240625211000830" style="zoom:33%;" />

### 实现思路

具体实现如下图所示，将生成的 HTML 文件写入 MinIO 中，在 文章内容表的 URL 的字段中回写对应的 url 地址。

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240625212248454.png" alt="image-20240625212248454" style="zoom:40%;" />

### 代码实现

1. 新建 `ArticleFreemarkerService` 创建静态文件并上传到 `minIO` 中

```java
public interface ArticleFreemarkerService {
    /**
     * 生成静态文件上传到minIO中
     * @param apArticle
     * @param content
     */
    public void buildArticleToMinIO(ApArticle apArticle, String content);
}
```

实现

```java
@Service
@Slf4j
@Transactional
public class ArticleFreemarkerServiceImpl implements ArticleFreemarkerService {

    @Autowired
    private ApArticleContentMapper apArticleContentMapper;

    @Autowired
    private Configuration configuration;

    @Autowired
    private FileStorageService fileStorageService;

    @Autowired
    private ApArticleService apArticleService;

    /**
     * 生成静态文件上传到minIO中
     * @param apArticle
     * @param content
     */
    @Async
    @Override
    public void buildArticleToMinIO(ApArticle apArticle, String content) {
        //已知文章的id
        //4.1 获取文章内容
        if(StringUtils.isNotBlank(content)){
            //4.2 文章内容通过freemarker生成html文件
            Template template = null;
            StringWriter out = new StringWriter();
            try {
                template = configuration.getTemplate("article.ftl");
                //数据模型
                Map<String,Object> contentDataModel = new HashMap<>();
                contentDataModel.put("content", JSONArray.parseArray(content));
                //合成
                template.process(contentDataModel,out);
            } catch (Exception e) {
                e.printStackTrace();
            }

            //4.3 把html文件上传到minio中
            InputStream in = new ByteArrayInputStream(out.toString().getBytes());
            String path = fileStorageService.uploadHtmlFile("", apArticle.getId() + ".html", in);

            //4.4 修改ap_article表，保存static_url字段
            apArticleService.update(Wrappers.<ApArticle>lambdaUpdate().eq(ApArticle::getId,apArticle.getId())
                    .set(ApArticle::getStaticUrl,path));

        }
    }

}
```

2. 在`ApArticleService`的`saveArticle`实现方法中添加调用生成文件的方法

```java
/**
     * 保存app端相关文章
     * @param dto
     * @return
     */
@Override
public ResponseResult saveArticle(ArticleDto dto) {

  ......
    //异步调用 生成静态文件上传到minio中
    articleFreemarkerService.buildArticleToMinIO(apArticle,dto.getContent());

  	//3.结果返回  文章的id
    return ResponseResult.okResult(apArticle.getId());
}
```

3. 文章微服务开启异步调用

```java
@SpringBootApplication
@EnableDiscoveryClient
@MapperScan("com.shawen.article.mapper")
@EnableAsync
public class ArticleApplication {

    public static void main(String[] args) {
        SpringApplication.run(ArticleApplication.class,args);
    }
  ......
}
```
