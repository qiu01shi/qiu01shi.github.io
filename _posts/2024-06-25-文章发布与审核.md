---
layout: post
title: 04 文章发布与审核
date: 2024-06-25 16:42 +0800
categories: [Blogging, TJU-news]
author: <author_id>
---

## 1. 文章数据流

如下图所示，文章发布主要分为以下几个步骤：

1. 在 `Media` 微服务发布文章，存入数据库中；异步调用文章审核方法；
2. 文章审核成功后，调用 `Article` 微服务保存文章，APP 端可以查看文章；

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240625164534731.png" alt="image-20240625164534731" style="zoom:40%;" />



## 2. 自媒体文章自动审核流程

### 调用第三方接口审核



<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240625204545996.png" alt="image-20240625204545996" style="zoom:35%;" />



1. 自媒体端发布文章后，借助第三方接口审核文章的内容（文本内容和图片）；
2. 图片存储在 `MinIO` 中，需先下载再审核；
3. 审核失败，则需要修改自媒体文章的状态，`status: 2`  审核失败   `status: 3`  转到人工审核；
4. 审核成功，则需要在文章微服务中创建 `app` 端需要的文章；



### 自定义敏感词过滤

`DFA` 实现原理：

- `DFA`全称为：**Deterministic Finite Automaton**，即 **确定有穷自动机**。

- 存储：一次性的把所有的敏感词存储到了多个 `map` 中，就是下图表示这种结构；

- 敏感词：冰毒、大麻、大坏蛋。

isEnd —> 1 敏感词结尾；	isEnd —> 0 不是敏感词结尾；

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240625205701594.png" alt="image-20240625205701594" style="zoom:45%;" />          <img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240625205723013.png" alt="image-20240625205723013" style="zoom:25%;" />



检索流程如下图所示：

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240625210054070.png" alt="image-20240625210054070" style="zoom:35%;" />

## 3. 文章详情

文章端创建 app 相关文章时，生成文章详情静态页上传到 MinIO 中：

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240625211000830.png" alt="image-20240625211000830" style="zoom:33%;" />

具体实现如下图所示，将生成的 HTML 文件写入 MinIO 中，在 文章内容表的 URL 的字段中回写对应的 url 地址。

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240625212248454.png" alt="image-20240625212248454" style="zoom:35%;" />



## 4. feign远程调用服务降级处理

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240625211932193.png" alt="image-20240625211932193" style="zoom:40%;" />

- 服务降级是服务自我保护的一种方式，或者保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用；
- 确保服务不会崩溃服务降级虽然会导致请求失败，但是不会导致阻塞。



## App 端文章保存

### 表结构

`ap_article` 文章信息表

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627165034466.png" alt="image-20240627165034466" style="zoom:45%;" />

`ap_article_config`  文章配置表

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627165142399.png" alt="image-20240627165142399" style="zoom:45%;" />

`ap_article_content` 文章内容表

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627165224548.png" alt="image-20240627165224548" style="zoom:45%;" />

### 分布式 id

随着业务的增长，文章表可能要占用很大的物理存储空间，为了解决该问题，后期使用数据库分片技术。将一个数据库进行拆分，通过数据库中间件连接。如果数据库中该表选用 ID 自增策略，则可能产生重复的 ID，此时应该使用分布式 ID 生成策略来生成 ID。

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627165341338.png" alt="image-20240627165341338" style="zoom:40%;" />

`snowflake` 是 `Twitter` 开源的分布式 ID 生成算法，结果是一个 long 型的 ID。其核心思想是：使用 41bit 作为毫秒数，10bit 作为机器的 ID（5个bit是数据中心，5个bit的机器ID），12bit 作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是 0。

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627165448306.png" alt="image-20240627165448306" style="zoom:45%;" />

文章端相关的表都使用雪花算法生成 id，包括 `ap_article`、 `ap_article_config`、 `ap_article_content`

`mybatis-plus` 已经集成了雪花算法，完成以下两步即可在项目中集成雪花算法

第一：在实体类中的 `id` 上加入如下配置，指定类型为 `id_worker`

```java
@TableId(value = "id",type = IdType.ID_WORKER)
private Long id;
```

第二：在 Nacos 中 `leadnews-article` 配置数据中心 `id` 和机器 `id`

```yaml
mybatis-plus:
  mapper-locations: classpath*:mapper/*.xml
  # 设置别名包扫描路径，通过该属性可以给包中的类注册别名
  type-aliases-package: com.shawen.model.article.pojos
  global-config:
    datacenter-id: 1
    workerId: 1
```

`datacenter-id`：数据中心 `id` (取值范围：0-31)

`workerId`：机器 `id` (取值范围：0-31)

 

### 思路分析

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627170156145.png" alt="image-20240627170156145" style="zoom:40%;" />

在文章审核成功以后需要在 `app` 的 `article` 库中新增文章数据

1. 保存文章信息 `ap_article`

2. 保存文章配置信息 `ap_article_config`

3. 保存文章内容 `ap_article_content`

### feign 接口

|          |       **说明**       |
| :------: | :------------------: |
| 接口路径 | /api/v1/article/save |
| 请求方式 |         POST         |
|   参数   |      ArticleDto      |
| 响应结果 |    ResponseResult    |

**ArticleDto：**

```java
@Data
public class ArticleDto  extends ApArticle {
    /**
     * 文章内容
     */
    private String content;
}
```



**ResponseResult：**

<img src="../media/2024-06-25-%E6%96%87%E7%AB%A0%E5%8F%91%E5%B8%83%E4%B8%8E%E5%AE%A1%E6%A0%B8/image-20240627170847298.png" alt="image-20240627170847298" style="zoom:50%;" />

### 代码实现

**①：在 `TJU-campus-feign-api` 中新增接口；**

第一：先导入feign的依赖

```xml
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-openfeign</artifactId>
</dependency>
```

第二：定义文章端的接口

```java
@FeignClient(value = "leadnews-article")
public interface IArticleClient {

    @PostMapping("/api/v1/article/save")
    public ResponseResult saveArticle(@RequestBody ArticleDto dto) ;
}
```

**②：在 TJU-campus-article 中实现该方法**

```java
package com.shawen.article.feign;

@RestController
public class ArticleClient implements IArticleClient {

    @Autowired
    private ApArticleService apArticleService;

    @Override
    @PostMapping("/api/v1/article/save")
    public ResponseResult saveArticle(@RequestBody ArticleDto dto) {
        return apArticleService.saveArticle(dto);
    }

}
```

在 `ApArticleService` 中新增方法，以及对应的实现类

```java
public interface ApArticleService extends IService<ApArticle> {

    /**
     * 保存app端相关文章
     * @param dto
     * @return
     */
    ResponseResult saveArticle(ArticleDto dto) ;
}
```



```java
@Service
@Transactional
@Slf4j
public class ApArticleServiceImpl  extends ServiceImpl<ApArticleMapper, ApArticle> implements ApArticleService {

		@Autowired
    private ApArticleConfigMapper apArticleConfigMapper;

    @Autowired
    private ApArticleContentMapper apArticleContentMapper;

    /**
     * 保存app端相关文章
     * @param dto
     * @return
     */
    @Override
    public ResponseResult saveArticle(ArticleDto dto) {
        //1.检查参数
        if(dto == null){
            return ResponseResult.errorResult(AppHttpCodeEnum.PARAM_INVALID);
        }

        ApArticle apArticle = new ApArticle();
        BeanUtils.copyProperties(dto,apArticle);

        //2.判断是否存在id
        if(dto.getId() == null){
            //2.1 不存在id  保存  文章  文章配置  文章内容

            //保存文章
            save(apArticle);

            //保存配置
            ApArticleConfig apArticleConfig = new ApArticleConfig(apArticle.getId());
            apArticleConfigMapper.insert(apArticleConfig);

            //保存 文章内容
            ApArticleContent apArticleContent = new ApArticleContent();
            apArticleContent.setArticleId(apArticle.getId());
            apArticleContent.setContent(dto.getContent());
            apArticleContentMapper.insert(apArticleContent);

        }else {
            //2.2 存在id   修改  文章  文章内容

            //修改  文章
            updateById(apArticle);

            //修改文章内容
            ApArticleContent apArticleContent = apArticleContentMapper.selectOne(Wrappers.<ApArticleContent>lambdaQuery().eq(ApArticleContent::getArticleId, dto.getId()));
            apArticleContent.setContent(dto.getContent());
            apArticleContentMapper.updateById(apArticleContent);
        }


        //3.结果返回  文章的id
        return ResponseResult.okResult(apArticle.getId());
    }
}
```









