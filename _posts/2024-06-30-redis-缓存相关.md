---
layout: post
title: 09 Redis 缓存穿透与一致性
date: 2024-06-30 21:38 +0800
categories: [Blogging,TJU-news]
author: <author_id>  
---

## 布隆过滤器解决缓存穿透

### 原理

将所有存在的 `key` 提前存入布隆过滤器，在访问缓存层之前，先通过 **过滤器拦截**，若请求的是不存在的 `key`，**则直接返回空值**。布隆过滤器主要是用于检索一个元素是否在一个集合中。

**实现原理：**

布隆过滤器由`「初始值都为 0 的位图数组」`和 `「 N 个哈希函数」` 两部分组成。当我们在写入数据库数据时，在布隆过滤器里做个标记，这样下次查询数据是否在数据库时，只需要查询布隆过滤器，**如果查询到数据没有被标记，说明不在数据库中**。

布隆过滤器会通过 **3 个操作完成标记**：

- 第一步，使用 `N 个哈希函数`分别对数据做`哈希计算`，得到 N 个哈希值；
- 第二步，将第一步得到的 N 个哈希值对位图数组的长度取模，得到 **每个哈希值在位图数组的对应位置**。
- 第三步，将每个哈希值在位图数组的 **对应位置的值设置为 1**；

当然是有缺点的，布隆过滤器有可能会产生一定的误判，我们一般可以设置这个误判率，大概不会超过 1%，其实这个误判是必然存在的，要不就得增加数组的长度，其实已经算是很划分了，`1%` 以内的误判率一般的项目也能接受，不至于高并发下压倒数据库。

所以，**查询布隆过滤器说数据存在，并不一定证明数据库中存在这个数据，但是查询到数据不存在，数据库中一定就不存在这个数据**。



### 相关配置

pom 文件中加入 Redisson 依赖：

```xml
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson-spring-boot-starter</artifactId>
    <version>3.16.2</version>
</dependency>
```

Nacos 中对应的 Redis 配置：

```yaml
spring:
  redis:
    host: localhost
    password: xxxx
    port: xxxx
```

配置类：

```java
@Configuration
@RefreshScope
public class RedissonConfig {

    @Value("${redis.host}")
    private String redisHost;

    @Value("${redis.port}")
    private int redisPort;

    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        config.useSingleServer().setAddress("redis://" + redisHost + ":" + redisPort);
        return Redisson.create(config);
    }

    @Bean
    public RBloomFilter<String> articleBloomFilter(RedissonClient redissonClient) {
        RBloomFilter<String> bloomFilter = redissonClient.getBloomFilter("articleBloomFilter");
        bloomFilter.tryInit(1000000L, 0.01);	// 误判率 1%
        return bloomFilter;
    }
}
```

### 代码实现

```java
		@Autowired
 		private RBloomFilter<String> articleBloomFilter;
  
    @PostConstruct
    public void init() {
        // 初始化布隆过滤器，并加载所有文章ID
        List<Long> articleIds = articleMapper.findAllArticleIds();
        bloomFilter = BloomFilter.create(Funnels.longFunnel(), articleIds.size());
        for (Long id : articleIds) {
            bloomFilter.put(id);
        }
    }  	

    // 检查布隆过滤器是否包含该缓存键
    if (!articleBloomFilter.contains(fieldKey)) {
      // 如果布隆过滤器不包含该键，直接返回空结果
      return ResponseResult.okResult(Collections.emptyList());
    }
  
  ......
}
```

## 使用 hash 结构保存数据

### 代码实现

```java
@Service
public class CacheService {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    public String get(String key, String field) {
        return (String) redisTemplate.opsForHash().get(key, field);
    }

    public void set(String key, String field, String value, long timeout, TimeUnit unit) {
        redisTemplate.opsForHash().put(key, field, value);
        redisTemplate.expire(key, timeout, unit);
    }

    public void set(String key, Map<String, String> values, long timeout, TimeUnit unit) {
        redisTemplate.opsForHash().putAll(key, values);
        redisTemplate.expire(key, timeout, unit);
    }
}
```

Impl：

```java
		// 2.查询数据
		String cacheKey = "articleList:" + dto.getTag();
		String fieldKey = loadtype + ":" + dto.getSize() + ":" + dto.getMaxBehotTime().getTime() + ":" + dto.getMinBehotTime().getTime();


    // 尝试从缓存中获取数据
    String cachedResult = cacheService.get(cacheKey, fieldKey);
    if (StringUtils.isNotBlank(cachedResult)) {
    		List<ApArticle> apArticles = JSON.parseArray(cachedResult, ApArticle.class);
	      return ResponseResult.okResult(apArticles);
    }

		// 如果缓存中没有数据，从数据库中查询
		......
      
    // 将结果存入缓存
    Map<String, String> cacheMap = new HashMap<>();
		cacheMap.put(fieldKey, JSON.toJSONString(apArticles));
		cacheService.set(cacheKey, cacheMap, 10, TimeUnit.MINUTES);
```

**缓存键和字段设计**：

- 缓存键：使用文章频道 `tag` 作为 Redis 哈希的键，避免重复存储不同频道的文章列表。
- 字段键：使用 `loadtype`、`size`、`maxBehotTime` 和 `minBehotTime` 作为哈希字段，确保字段唯一性和数据隔离。



### 与 String 相比的优点

1. **更高效的部分更新和读取**：使用哈希结构可以更高效地更新和读取部分数据，而不必读取或写入整个字符串。
2. **节省内存**：哈希结构可以更紧凑地存储数据，节省内存空间。
3. **组织更清晰**：将相关的数据组织在一起，便于管理和查询。



## Cache Aside 策略 实现双写一致

该策略又可以细分为 `「读策略」` 和 `「写策略」`。

<img src="../media/2024-06-30-redis-%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3/image%20(1).png" alt="image (1)" style="zoom:50%;" />

**读策略的步骤：**

- 如果读取的数据命中了缓存，则直接返回数据；
- 如果读取的数据没有命中缓存，则从数据库中读取数据，然后将数据写入到缓存，并且返回给用户。



**写策略的步骤：**

- 更新数据库中的数据；
- 删除缓存中的数据。



### 先更新数据库，再删除缓存

一般情况下，**可以保证数据的一致性**。

<img src="../media/2024-06-30-redis-%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3/image%20(3).png" alt="image (3)" style="zoom:50%;" />

### 删除缓存，再更新数据库

<img src="../media/2024-06-30-redis-%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3/image%20(2).png" alt="image (2)" style="zoom:50%;" />

**解决方法：**

- 针对 `「先删除缓存，再更新数据库」`，**延迟双删**；但第二次删除的时间难以控制；







**如何保证「先更新数据库 ，再删除缓存」这两个操作能执行成功？**

- **重试机制**

我们可以引入 **消息队列**，将 **第二个操作（删除缓存）要操作的数据加入到消息队列**，由消费者来操作数据。

1. 如果应用 **删除缓存失败**，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是 **重试机制**。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。
2. 如果 **删除缓存成功**，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。

<img src="../media/2024-06-30-redis-%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3/image%20(4).png" alt="image (4)" style="zoom:60%;" />
