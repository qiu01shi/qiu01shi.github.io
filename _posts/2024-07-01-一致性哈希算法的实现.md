---
layout: post
title: 一致性哈希算法的实现
date: 2024-07-01 20:09 +0800
categories: [Blogging,MyOwnRPC]
author: <author_id>  
---

## 一致性哈希算法的实现

```java
@Slf4j
public class ConsistentHashLoadBalance extends AbstractLoadBalance {
    private final ConcurrentHashMap<String, ConsistentHashSelector> selectors = new ConcurrentHashMap<>();

    @Override
    protected String doSelect(List<String> serviceAddresses, RpcRequest rpcRequest) {
    //暂略
    }
  
    static class ConsistentHashSelector {
    //暂略
    }
}
```

`ConsistentHashLoadBalance` 是一个继承自 `AbstractLoadBalance` 的类，负责在给定的一组服务地址中选择一个合适的服务地址来处理特定的 RPC 请求。

`selectors`: `ConcurrentHashMap<String, ConsistentHashSelector>` 类型，用于存储每个 RPC 服务名称对应的一致性哈希选择器。



方法：`doSelect` 用于选择一个合适的服务地址。

`ConsistentHashSelector` 是一个内部类，负责一致性哈希算法的具体实现。



### doSelect 方法

```java
protected String doSelect(List<String> serviceAddresses, RpcRequest rpcRequest) {
    // 获取服务地址列表的身份哈希码，用于检测服务地址列表是否发生变化。
    int identityHashCode = System.identityHashCode(serviceAddresses);
    // build rpc service name by rpcRequest
    String rpcServiceName = rpcRequest.getRpcServiceName();
    // 获取与 rpcServiceName 关联的 ConsistentHashSelector 实例。
    ConsistentHashSelector selector = selectors.get(rpcServiceName);
    // check for updates
    // 条件成立，则创建一个新的 ConsistentHashSelector 实例并更新 selectors；
    if (selector == null || selector.identityHashCode != identityHashCode) {
        selectors.put(rpcServiceName, new ConsistentHashSelector(serviceAddresses, 160, identityHashCode));
        selector = selectors.get(rpcServiceName);
    }
    return selector.select(rpcServiceName + Arrays.stream(rpcRequest.getParameters()));
}
```



### ConsistentHashSelector 内部类

```java
static class ConsistentHashSelector {
  private final TreeMap<Long, String> virtualInvokers;
  private final int identityHashCode;

  ConsistentHashSelector(List<String> invokers, int replicaNumber, int identityHashCode) {

  }

  static byte[] md5(String key) {}

  static long hash(byte[] digest, int idx) {}

  public String select(String rpcServiceKey) {}

  public String selectForKey(long hashCode) {}

}
```



**属性：**

- `virtualInvokers`: `TreeMap<Long, String>` 类型，存储虚拟节点与实际服务地址之间的映射关系。
- `identityHashCode`: 标识服务地址列表的身份哈希码。



**构造方法：**

```java
ConsistentHashSelector(List<String> invokers, int replicaNumber, int identityHashCode) {
    this.virtualInvokers = new TreeMap<>();
    this.identityHashCode = identityHashCode;

    for (String invoker : invokers) {
        for (int i = 0; i < replicaNumber / 4; i++) {
            byte[] digest = md5(invoker + i);
            for (int h = 0; h < 4; h++) {
                long m = hash(digest, h);
                virtualInvokers.put(m, invoker);
            }
        }
    }
}
```



`virtualInvokers` 初始化为空的 `TreeMap`。

对于每个服务地址（`invoker`），生成若干虚拟节点（由 `replicaNumber` 决定），通过 MD5 哈希算法生成虚拟节点的哈希值，并将虚拟节点和实际服务地址的映射存储在 `virtualInvokers` 中。



**处理逻辑的详细解释：**

- **一致性哈希和虚拟节点**

一致性哈希是一种哈希算法，它将所有可能的哈希值空间看作一个环，然后将每个服务节点（即服务地址 `invoker`）映射到这个环上的多个点（虚拟节点）。当需要选择一个服务节点来处理请求时，首先将请求映射到环上的某个点，然后沿环顺时针查找最近的节点。这种方式的好处是当服务节点发生变化时，只有少量的请求会重新分配到其他节点，从而保证了负载均衡的稳定性和高效性。

- **为什么要创建虚拟节点？**

在实际场景中，服务节点的数量可能很少。如果仅仅使用真实的服务节点作为哈希环上的节点，会导致哈希值分布不均匀，某些节点会承担过多的请求，而某些节点几乎没有请求。这种负载不均衡的问题可以通过引入虚拟节点来解决。

虚拟节点是对实际服务节点的复制，每个实际节点会被映射到多个虚拟节点上。虚拟节点的数量越多，哈希值的分布就越均匀，负载均衡效果越好。

- **具体实现步骤**

1. **遍历服务地址列表**：对于每个实际服务地址 `invoker`，需要在哈希环上创建多个虚拟节点。

```java
for (String invoker : invokers) {
```

2. **创建多个虚拟节点**：对于每个 `invoker`，我们创建 `replicaNumber / 4` 个虚拟节点。`replicaNumber` 是一个预定义的常量，表示每个实际节点应该有多少个虚拟节点。为什么除以 4？因为每个虚拟节点会被分成 4 个部分进行哈希计算。

```java
for (int i = 0; i < replicaNumber / 4; i++) {
```
3. **计算 MD5 哈希值**：对 `invoker` 加上一个索引 `i` 进行 MD5 哈希计算，生成一个 128 位的哈希值。这个哈希值会被分成 4 个部分，每部分用于生成一个虚拟节点的哈希值。

```java
byte[] digest = md5(invoker + i);
```

4. **生成虚拟节点的哈希值**：从 MD5 哈希值中提取 4 个部分，每部分用来生成一个虚拟节点的哈希值，并将这些虚拟节点映射到实际节点 `invoker` 上。

```java
for (int h = 0; h < 4; h++) {
    long m = hash(digest, h);
    virtualInvokers.put(m, invoker);
}
```

- **为什么这么设计？**

1. **均匀分布哈希值**：通过创建多个虚拟节点，可以保证哈希值在环上的分布更均匀，从而避免负载不均衡的问题。
2. **减少哈希冲突**：使用 MD5 哈希值的 4 个部分，可以有效减少哈希冲突的概率，提高哈希环的查找效率。
3. **高效查找**：使用 `TreeMap` 存储虚拟节点，可以快速找到大于或等于某个哈希值的节点，实现高效的查找操作。
4. **容错和扩展性**：当服务节点发生变化时（增加或删除），只需要重新计算受影响的部分虚拟节点，不会对整个哈希环产生大的影响，从而保证系统的稳定性和扩展性。



**md5 方法：**

```java
static byte[] md5(String key) {
    MessageDigest md;
    try {
        md = MessageDigest.getInstance("MD5");
        byte[] bytes = key.getBytes(StandardCharsets.UTF_8);
        md.update(bytes);
    } catch (NoSuchAlgorithmException e) {
        throw new IllegalStateException(e.getMessage(), e);
    }

    return md.digest();
}
```

`MD5`（Message-Digest Algorithm 5）是一种广泛使用的加密哈希函数，可以将任意长度的输入消息（通常是字符串或文件）转换为一个固定长度的输出哈希值。MD5 产生的哈希值长度是 128 位，也就是 16 个字节（每个字节 8 位）。下面是对这个 `md5` 方法的详细解释：

1. 创建 MessageDigest 实例：

```java
md = MessageDigest.getInstance("MD5");
```

- `MessageDigest` 是 Java 提供的用于生成哈希值的类。
- `MessageDigest.getInstance("MD5")` 返回一个实现 MD5 算法的 `MessageDigest` 对象。
- 该方法可能会抛出 `NoSuchAlgorithmException`，如果系统不支持 MD5 算法。

2. 将输入字符串转换为字节数组：

```java
byte[] bytes = key.getBytes(StandardCharsets.UTF_8);
```

- 将输入的字符串 `key` 转换为字节数组，这里使用 UTF-8 编码。

- `UTF-8` 是一种常见的字符编码方式，能够兼容多种语言和字符集。

3. 更新 MessageDigest 对象：

```java
md.update(bytes);
```

- 使用 `update` 方法将字节数组传递给 `MessageDigest` 对象，进行哈希计算的准备。

4. 生成哈希值：

```java
return md.digest();
```

- `md.digest()` 方法完成哈希计算并返回哈希值。

- 该方法返回一个长度为 16 的字节数组，表示 128 位的 MD5 哈希值。



**hash 方法：**

```java
static long hash(byte[] digest, int idx) {
    return ((long) (digest[3 + idx * 4] & 255) << 24 |
            (long) (digest[2 + idx * 4] & 255) << 16 |
            (long) (digest[1 + idx * 4] & 255) << 8 |
            (long) (digest[idx * 4] & 255)) & 4294967295L;
}
```



