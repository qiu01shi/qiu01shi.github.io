---
layout: post
title: 一致性哈希算法的实现
date: 2024-07-01 20:09 +0800
categories: [Blogging,MyOwnRPC]
author: <author_id>  
---

## 一致性哈希算法的实现

```java
@Slf4j
public class ConsistentHashLoadBalance extends AbstractLoadBalance {
    private final ConcurrentHashMap<String, ConsistentHashSelector> selectors = new ConcurrentHashMap<>();

    @Override
    protected String doSelect(List<String> serviceAddresses, RpcRequest rpcRequest) {
    //暂略
    }
  
    static class ConsistentHashSelector {
    //暂略
    }
}
```

`ConsistentHashLoadBalance` 是一个继承自 `AbstractLoadBalance` 的类，负责在给定的一组服务地址中选择一个合适的服务地址来处理特定的 RPC 请求。

`selectors`: `ConcurrentHashMap<String, ConsistentHashSelector>` 类型，用于存储每个 RPC 服务名称对应的一致性哈希选择器。



方法：`doSelect` 用于选择一个合适的服务地址。

`ConsistentHashSelector` 是一个内部类，负责一致性哈希算法的具体实现。



### doSelect 方法

```java
protected String doSelect(List<String> serviceAddresses, RpcRequest rpcRequest) {
    // 获取服务地址列表的身份哈希码，用于检测服务地址列表是否发生变化。
    int identityHashCode = System.identityHashCode(serviceAddresses);
    // build rpc service name by rpcRequest
    String rpcServiceName = rpcRequest.getRpcServiceName();
    // 获取与 rpcServiceName 关联的 ConsistentHashSelector 实例。
    ConsistentHashSelector selector = selectors.get(rpcServiceName);
    // check for updates
    // 条件成立，则创建一个新的 ConsistentHashSelector 实例并更新 selectors；
    if (selector == null || selector.identityHashCode != identityHashCode) {
        selectors.put(rpcServiceName, new ConsistentHashSelector(serviceAddresses, 160, identityHashCode));
        selector = selectors.get(rpcServiceName);
    }
    return selector.select(rpcServiceName + Arrays.stream(rpcRequest.getParameters()));
}
```



### ConsistentHashSelector 内部类

```java
static class ConsistentHashSelector {
  private final TreeMap<Long, String> virtualInvokers;
  private final int identityHashCode;

  ConsistentHashSelector(List<String> invokers, int replicaNumber, int identityHashCode) {

  }

  static byte[] md5(String key) {}

  static long hash(byte[] digest, int idx) {}

  public String select(String rpcServiceKey) {}

  public String selectForKey(long hashCode) {}

}
```



**属性：**

- `virtualInvokers`: `TreeMap<Long, String>` 类型，存储虚拟节点与实际服务地址之间的映射关系。
- `identityHashCode`: 标识服务地址列表的身份哈希码。



**构造方法：**

```java
ConsistentHashSelector(List<String> invokers, int replicaNumber, int identityHashCode) {
    this.virtualInvokers = new TreeMap<>();
    this.identityHashCode = identityHashCode;

    for (String invoker : invokers) {
        for (int i = 0; i < replicaNumber / 4; i++) {
            byte[] digest = md5(invoker + i);
            for (int h = 0; h < 4; h++) {
                long m = hash(digest, h);
                virtualInvokers.put(m, invoker);
            }
        }
    }
}
```



`virtualInvokers` 初始化为空的 `TreeMap`。

对于每个服务地址（`invoker`），生成若干虚拟节点（由 `replicaNumber` 决定），通过 MD5 哈希算法生成虚拟节点的哈希值，并将虚拟节点和实际服务地址的映射存储在 `virtualInvokers` 中。



**处理逻辑的详细解释：**

- **一致性哈希和虚拟节点**

一致性哈希是一种哈希算法，它将所有可能的哈希值空间看作一个环，然后将每个服务节点（即服务地址 `invoker`）映射到这个环上的多个点（虚拟节点）。当需要选择一个服务节点来处理请求时，首先将请求映射到环上的某个点，然后沿环顺时针查找最近的节点。这种方式的好处是当服务节点发生变化时，只有少量的请求会重新分配到其他节点，从而保证了负载均衡的稳定性和高效性。

- **为什么要创建虚拟节点？**

在实际场景中，服务节点的数量可能很少。如果仅仅使用真实的服务节点作为哈希环上的节点，会导致哈希值分布不均匀，某些节点会承担过多的请求，而某些节点几乎没有请求。这种负载不均衡的问题可以通过引入虚拟节点来解决。

虚拟节点是对实际服务节点的复制，每个实际节点会被映射到多个虚拟节点上。虚拟节点的数量越多，哈希值的分布就越均匀，负载均衡效果越好。

- **具体实现步骤**

1. **遍历服务地址列表**：对于每个实际服务地址 `invoker`，需要在哈希环上创建多个虚拟节点。

```java
for (String invoker : invokers) {
```

2. **创建多个虚拟节点**：对于每个 `invoker`，我们创建 `replicaNumber / 4` 个虚拟节点。`replicaNumber` 是一个预定义的常量，表示每个实际节点应该有多少个虚拟节点。为什么除以 4？因为每个虚拟节点会被分成 4 个部分进行哈希计算。

```java
for (int i = 0; i < replicaNumber / 4; i++) {
```

3. **计算 MD5 哈希值**：对 `invoker` 加上一个索引 `i` 进行 MD5 哈希计算，生成一个 128 位的哈希值。这个哈希值会被分成 4 个部分，每部分用于生成一个虚拟节点的哈希值。

```java
byte[] digest = md5(invoker + i);
```

4. **生成虚拟节点的哈希值**：从 MD5 哈希值中提取 4 个部分，每部分用来生成一个虚拟节点的哈希值，并将这些虚拟节点映射到实际节点 `invoker` 上。





