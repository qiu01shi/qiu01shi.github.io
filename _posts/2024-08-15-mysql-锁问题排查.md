---
layout: post
title: mysql 锁问题排查
date: 2024-08-15 13:51 +0800
categories: [基础知识, MYSQL 实战 45 讲]
author: <author_id>
---

## 1、问题描述

在做订单平台的过程中，发现了一些关于锁的问题，举例说明；

测试过程中有 `Lock wait timeout exceeded; try restarting transaction` 这种的报错，并且不是必现（死锁问题）



## 2. 问题解决

针对上面问题，首先第一个想到就是死锁了，马上搜索下死锁的查询步骤，这个基本大同小异，一个语句就可以了， `show engine innodb status \G;` 主要看 `LATEST DETECTED DEADLOCK` 下面的信息：



![image (1)](../media/2024-08-15-mysql-%E9%94%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/image%20(1).png)

1）、蓝色框的事务里在等待绿色框的事务拥有的锁，而绿色框的事务在等待蓝色框的事务拥有的锁，二者相互僵持，导致死锁了，然后回忆下代码，哪里可能造成这种问题，看了半天代码还真有；

代码基本思路是：

```go
begin:
go func() {
    select * from soda_order_base_521405050 where order_id = ? for udpate;
    update soda_order_base_521405050 set XXX where XXX
}()
go func() {
    select * from order_status_52140500 where order_id = ? and role = ? for update
    update order_status_52140500 set XXX where XXX
}()
commit;
```

在写老数据的时候，双写新表，为了让效率提升，写老表与新表分别开了两个协程，这样就有可能出现并发时两个表写入的顺序不一致，导致都在等在另一个协程持有的锁；

以为问题就到此结束了，之后把新表的数据全部清空之后，再次测试，发现还有 `Lock wait timeout exceeded; try restarting transaction` 这个问题，搞的很崩溃，只能继续 `debug`，幸好问题复现频率较高，在出问题的请求后依次在 db 执行了以下命令：

a、 `SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS；` 查看当前db的锁情况

b、 `SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;`  这些锁的等待关系

c、 `show processlist;`  查看是哪些sql在执行

d、 `show engine innodb status \\G;`  是否是新的死锁情况



通过以上分析，首先确定不是死锁问题，然后整体的执行情况如下：

![deadlockinformation](../media/2024-08-15-mysql-%E9%94%81%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/deadlockinformation.png)

第一个是当前执行的sql，有两个是我们这次的；

第二个我们发现锁持有与等待的关系，trx_id 为 112227911、112228215 持有 order_ext_takeaway_b_52140500 表的 间隙锁，而 trx_id为 112228297 在等待上两个事务的锁释放，最后是 trx_id 为 112228298 的事务等在 trx_id 为 112228297的锁，到此整体现状应该比较清晰了；



在此解释下几个知识点

1、 `lock_data：supremum pseudo-record`      `select XXX where id = N for update` 或者 `udpate XXX where  id = N`  当 N 超过表里的最大值时，两种方式都会对 `primary` 索引的 `supremum pseudo-record` 加一个 X 锁，导致其他的 `insert` 会被阻塞， `supremum pseudo-record` :相当于比索引中所有值都大，但却不存在索引中，相当于最后一行之后的 间隙锁；



2、锁互斥情况：间隙锁 与 间隙锁 是兼容的，插入意向锁 与 间隙锁 互斥

上面的情况是 trx_id 为 112227911、112228215 为两个update 语句（此语句没有找到记录，上文说了，重新测试把数据都删了），trx_id 为 112228297为一个 insert 语句，而 update 在一个事务里，只写了 begin，没有 commit（是一个bug），导致线下测试时候事务一直处于未提交状态，从而把 insert 事务给阻塞了，导致了此现象，排查代码后把问题修复。



ps：

为什么阻塞？就是上面说到的两个知识点，两个update语句持有的是间隙锁，他们的间隙是从 N~正无穷，间隙锁之间是兼容的，所以两个update不互斥，可执行

但是当我们要插入数据是，需要向表加入 插入意向锁，此时，插入意向锁与间隙锁是互斥的，故等待。



到此，问题基本都已经解决。



参考资料如下：

https://zhuanlan.zhihu.com/p/245556254

https://learnku.com/articles/49189

https://blog.csdn.net/zhanghongzheng3213/article/details/53436240

https://blog.csdn.net/cuique7070/article/details/100338839/

https://blog.csdn.net/weixin_28725037/article/details/113121231









































