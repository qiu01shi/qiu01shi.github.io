---
layout: post
title: Redis 基本数据结构
date: 2024-07-02 11:38 +0800
categories: [Blogging,Redis]
author: <author_id>  
---

## 基本数据类型

### String

**字符串类型**，是redis中最基本的数据类型，一个 `key` 对应一个 `value`。

`String` 类型是 **二进制安全** 的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。

**使用**：`get` 、`set`、`del`、`incr`、`decr` 等

**实战场景：**

1. 缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql 的读写压力。
2. 计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。
3. session：常见方案 spring session + redis 实现session共享，



### List

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713767398240-5ffe163a-1772-4caf-ba9e-95c48cea5d5c-20240702114043627.png" alt="img" style="zoom:80%;" />

**使用双端链表实现** `List`**，有序的，**`value` **可以重复，**可以通过下标取出对应的 value 值，左右两边都能进行插入和删除数据。

**实战场景：**

- timeline：例如微博的时间轴，有人发布微博，用 `lpush` 加入时间轴，展示新的列表信息。



### Hash

**哈希类型**，是一个 `Mapmap`，指值本身又是一种键值对结构。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713767319569-40f1112c-4926-41be-a7d1-a6b38599934b.png" alt="img" style="zoom:80%;" />



使用：所有hash的命令都是 h 开头的 `hget`、`hset` 、`hdel` 等

**实战场景：**

- 缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。



### Set

集合类型也是用来保存多个字符串的元素，但和列表不同的是集合中 

1. **不允许有重复的元素**；
2. 集合中的 **元素是无序的**，不能通过索引下标获取元素，
3. 支持 **集合间的操作**，可以取多个集合取交集、并集、差集。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713767544186-63000669-dcb7-4143-a066-ed399eb77697.png" alt="img" style="zoom:60%;" />

**实战场景：**

1. 标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人；
2. 点赞，或点踩，收藏等，可以放到set中实现。

### Zset

有序集合和集合有着必然的联系，保留了集合不能有重复成员的特性，区别是，有序集合中的元素是可以排序的，它 `给每个元素设置一个分数`，作为排序的依据。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713767621333-9ee948fc-d508-433d-9146-6932e9c63264.png" alt="img" style="zoom:60%;" />



## 基本数据类型的底层实现

### 对象的类型与编码

`Redis` 使用前面说的五大数据类型来表示键和值，每次在 `Redis` 数据库中创建一个键值对时，至少会创建两个对象，一个是 **键对象**，一个是 **值对象**，而`Redis`中的每个对象都是由`redisObject`结构来表示：

```java
typedef struct redisObject{
   unsigned type:4;   	//类型
   unsigned encoding:4;   //编码
   void *ptr;   	//指向底层数据结构的指针
   int refcount;   	//引用计数
   unsigned lru:22;	 	//记录最后一次被程序访问的时间
}robj
```

① **type属性**

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713767982048-ecccd52a-ca63-420b-8478-b203d5d447c7.png" alt="img" style="zoom:70%;" />

在Redis中，**键总是一个字符串对象**，而 **值可以是字符串、列表、集合等对象**，所以我们通常说的键为字符串键，表示的是这个键对应的值为字符串对象，我们说一个键为集合键时，表示的是这个键对应的值为集合对象。



**② encoding 属性和** `prt` **指针**

对象的 prt 指针指向对象底层的数据结构，而 **数据结构由 encoding 属性** 来决定。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713768123116-6060c1ff-672a-45eb-80a5-bc1d35ad9952.png" alt="img" style="zoom:60%;" />

而每种类型的对象都至少使用了两种不同的编码：

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713768193628-504c2497-6bf1-4c1e-9dfe-fcf7e8154894.png" alt="img" style="zoom:60%;" />

简单来说，底层数据结构一共有6种，分别是 **简单动态字符串**、**双向链表**、**压缩列表**、**哈希表**、**跳表** 和 **整数数组**。它们和数据类型的对应关系如下图所示：

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/88f2621e-44bd-47a4-8e03-8e1e94664d0d.jpg" alt="88f2621e-44bd-47a4-8e03-8e1e94664d0d" style="zoom:15%;" />

### 动态字符串SDS

我们都知道Redis中保存的Key是字符串，value往往是字符串或者字符串的集合。可见字符串是Redis中最常用的一种数据结构。

不过Redis没有直接使用C语言中的字符串，因为C语言字符串存在很多问题：

```c
// c语言，声明字符串
char* s = "hello"
// 本质是字符数组： {'h', 'e', 'l', 'l', 'o', '\0'}
```

- 获取字符串长度的需要通过运算
- 非二进制安全
- 不可修改

Redis构建了一种新的字符串结构，称为简单动态字符串（Simple Dynamic String），简称SDS。

Redis是C语言实现的，其中SDS是一个结构体，源码如下：

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240702125036434.png" alt="image-20240702125036434" style="zoom:45%;" />

例如，一个包含字符串`“name”`的 `sds` 结构如下：

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240702125129731.png" alt="image-20240702125129731" style="zoom:50%;" />

`SDS` 之所以叫做动态字符串，是因为它具备动态扩容的能力，例如一个内容为`“hi”`的SDS：

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240702125228174.png" alt="image-20240702125228174" style="zoom:50%;" />

假如我们要给`SDS`追加一段字符串`“,Amy”`，这里首先会申请新内存空间：

- 如果新字符串小于`1M`，则新空间为扩展后字符串长度的两倍 +1；

- 如果新字符串大于`1M`，则新空间为扩展后字符串长度+1M+1。

该过程称为 **内存预分配**。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240702125455503.png" alt="image-20240702125455503" style="zoom:50%;" />

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240702125505998.png" alt="image-20240702125505998" style="zoom:50%;" />

### IntSet 部分

IntSet是Redis中set集合的一种实现方式，基于整数数组来实现，并且具备长度可变、有序等特征。结构如下：

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240702125608460.png" alt="image-20240702125608460" style="zoom:50%;" />

其中的 `encoding` 包含三种模式，表示存储的整数大小不同：

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240702125632276.png" alt="image-20240702125632276" style="zoom:50%;" />

为了方便查找，Redis会将intset中所有的整数按照升序依次保存在contents数组中，结构如图：

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240702130028648.png" alt="image-20240702130028648" style="zoom:50%;" />

找到数组中某个元素的 **寻址公式：**

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240702130059093.png" alt="image-20240702130059093" style="zoom:50%;" />

现在，数组中每个数字都在int16_t的范围内，因此采用的编码方式是 `INTSET_ENC_INT16`，每部分占用的字节大小为：

- `encoding`：4字节
- `length`：4字节
- `contents`：2字节 * 3  = 6字节



**IntSet 升级：**

现在，假设有一个 `intset`，元素为 `{5,10，20}`，采用的编码是 `INTSET_ENC_INT16`，则每个整数占2字节：

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240703013320566.png" alt="image-20240703013320566" style="zoom:50%;" />

我们向该其中添加一个数字：50000，这个数字超出了`int16_t`的范围，`intset`会自动升级编码方式到合适的大小。以当前案例来说流程如下：

①：升级编码为 `INTSET_ENC_INT32`, 每个整数占4字节，并按照新的编码方式及元素个数扩容数组；

② ：倒序依次将数组中的元素拷贝到扩容后的正确位置；

③：将待添加的元素放入数组末尾；

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240703013912236.png" alt="image-20240703013912236" style="zoom:50%;" />

④：最后，将 `inset` 的 `encoding` 属性改为 `INTSET_ENC_INT32`，将 `length` 属性改为4

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240703013825878.png" alt="image-20240703013825878" style="zoom:50%;" />



**源码：**

```c++
intset *intsetAdd(intset *is, int64_t value, uint8_t *success) {
    uint8_t valenc = _intsetValueEncoding(value);// 获取当前值编码
    uint32_t pos; // 要插入的位置
    if (success) *success = 1;
    // 判断编码是不是超过了当前intset的编码
    if (valenc > intrev32ifbe(is->encoding)) {
        // 超出编码，需要升级
        return intsetUpgradeAndAdd(is,value);
    } else {
        // 在当前intset中查找值与value一样的元素的角标pos
        if (intsetSearch(is,value,&pos)) {
            if (success) *success = 0; //如果找到了，则无需插入，直接结束并返回失败
            return is;
        }
        // 数组扩容
        is = intsetResize(is,intrev32ifbe(is->length)+1);
        // 移动数组中pos之后的元素到pos+1，给新元素腾出空间
        if (pos < intrev32ifbe(is->length)) intsetMoveTail(is,pos,pos+1);
    }
    // 插入新元素
    _intsetSet(is,pos,value);
    // 重置元素长度
    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);
    return is;
}
```

```c++
static intset *intsetUpgradeAndAdd(intset *is, int64_t value) {
    // 获取当前intset编码
    uint8_t curenc = intrev32ifbe(is->encoding);
    // 获取新编码
    uint8_t newenc = _intsetValueEncoding(value);
    // 获取元素个数
    int length = intrev32ifbe(is->length); 
    // 判断新元素是大于0还是小于0 ，小于0插入队首、大于0插入队尾
    int prepend = value < 0 ? 1 : 0;
    // 重置编码为新编码
    is->encoding = intrev32ifbe(newenc);
    // 重置数组大小
    is = intsetResize(is,intrev32ifbe(is->length)+1);
    // 倒序遍历，逐个搬运元素到新的位置，_intsetGetEncoded按照旧编码方式查找旧元素
    while(length--) // _intsetSet按照新编码方式插入新元素
        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));
    /* 插入新元素，prepend决定是队首还是队尾*/
    if (prepend)
        _intsetSet(is,0,value);
    else
        _intsetSet(is,intrev32ifbe(is->length),value);
    // 修改数组长度
    is->length = intrev32ifbe(intrev32ifbe(is->length)+1);
    return is;
}
```

**总结：**

`Intset`可以看做是特殊的整数数组，具备一些特点：

①：Redis会确保Intset中的元素唯一、有序

② ：具备类型升级机制，可以节省内存空间

③：底层采用二分查找方式来查询



### Dict 部分

`Redis`是一个键值型`（Key-Value Pair）`的数据库，我们可以根据键实现快速的增删改查。而键与值的映射关系正是通过 Dict来实现的。

`Dict` 由三部分组成，分别是：哈希表（DictHashTable）、哈希节点（DictEntry）、字典（Dict）

先来介绍 哈希表（DictHashTable）和 哈希节点（DictEntry）的结构，如下：

```c++
typedef struct dictht {
    // entry数组
    // 数组中保存的是指向entry的指针
    dictEntry **table; 
    // 哈希表大小
    unsigned long size;
    // 哈希表大小的掩码，总等于size - 1
    unsigned long sizemask;
    // entry个数
    unsigned long used; 
} dictht;
```

```c++
typedef struct dictEntry {
    void *key; // 键
    union { // 联合体，表示四个中的一个，但不能同时成立；
        void *val; // 可以指向任意的类型
        uint64_t u64;
        int64_t s64;
        double d;
    } v; // 值
    // 下一个Entry的指针
    struct dictEntry *next; 
} dictEntry;
```

当我们向 `Dict` 添加键值对时，Redis 首先根据 `key` 计算出 `hash` 值（h），然后利用 `h & sizemask`来计算元素应该存储到数组中的哪个索引位置。

我们存储 `k1 = v1`，假设 `k1` 的哈希值 `h =1`，则 `1&3 =1`，因此 `k1=v1` 要存储到数组角标 `1` 位置。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240703153243431.png" alt="image-20240703153243431" style="zoom:50%;" />

当与 `k2 = v2` 发生冲突时：

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240703153335114.png" alt="image-20240703153335114" style="zoom:32%;" />

字典（Dict）

```c++
typedef struct dict {
    dictType *type; // dict类型，内置不同的hash函数
    void *privdata;    // 私有数据，在做特殊hash运算时用
    dictht ht[2]; // 一个Dict包含两个哈希表，其中一个是当前数据，另一个一般是空，rehash时使用
    long rehashidx;    // rehash的进度，-1表示未进行
    int16_t pauserehash; // rehash是否暂停，1则暂停，0则继续
} dict;
```

**基本结构如下所示：**

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240703153836446.png" alt="image-20240703153836446" style="zoom:50%;" />

<font color="red">Dict的扩容</font>

`Dict`中的 `HashTable` 就是数组结合单向链表的实现，当集合中元素较多时，必然导致哈希冲突增多，链表过长，则查询效率会大大降低。

`Dict` 在每次新增键值对时都会检查负载因子（`LoadFactor = used/size`） ，满足以下两种情况时会触发哈希表扩容：

- 哈希表的 `LoadFactor >= 1`，并且服务器没有执行 `BGSAVE` 或者 `BGREWRITEAOF` 等后台进程；
- 哈希表的 `LoadFactor > 5` ；

```c++
static int _dictExpandIfNeeded(dict *d) {
    // 如果正在rehash，则返回ok
    if (dictIsRehashing(d)) return DICT_OK;

    // 如果哈希表为空，则初始化哈希表为默认大小：4
    if (d->ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);

    // 当负载因子（used/size）达到1以上，并且当前没有进行bgrewrite等子进程操作
    // 或者负载因子超过5，则进行 dictExpand ，也就是扩容
    if (d->ht[0].used >= d->ht[0].size &&
        (dict_can_resize || d->ht[0].used / d->ht[0].size > dict_force_resize_ratio)) {
        // 扩容大小为used + 1，底层会对扩容大小做判断，实际上找的是第一个大于等于 used+1 的 2^n
        return dictExpand(d, d->ht[0].used + 1);
    }

    return DICT_OK;
}
```

<font color="red">Dict 的收缩</font>

`Dict` 除了扩容以外，每次删除元素时，也会对负载因子做检查，当 `LoadFactor < 0.1` 时，会做哈希表收缩：

```c++
// t_hash.c # hashTypeDeleted()
...
if (dictDelete((dict*)o->ptr, field) == C_OK) {
    deleted = 1;
    // 删除成功后，检查是否需要重置Dict大小，如果需要则调用dictResize重置
    /* Always check if the dictionary needs a resize after a delete. */
    if (htNeedsResize(o->ptr)) dictResize(o->ptr);
}
...
```

```c++
// server.c 文件
int htNeedsResize(dict *dict) {
    long long size, used;
    // 哈希表大小
    size = dictSlots(dict);
    // entry数量
    used = dictSize(dict);
    // size > 4（哈希表初始大小）并且 负载因子低于0.1
    return (size > DICT_HT_INITIAL_SIZE && (used * 100 / size < HASHTABLE_MIN_FILL));
}
```

```c++
int dictResize(dict *d) {
    unsigned long minimal;
    // 如果正在做bgsave或bgrewriteof或rehash，则返回错误
    if (!dict_can_resize || dictIsRehashing(d)) 
        return DICT_ERR;
    // 获取used，也就是entry个数
    minimal = d->ht[0].used;
    // 如果used小于4，则重置为4
    if (minimal < DICT_HT_INITIAL_SIZE)
        minimal = DICT_HT_INITIAL_SIZE;
    // 重置大小为minimal，其实是第一个大于等于minimal的2^n
    return dictExpand(d, minimal);
}
```



不管是扩容还是收缩，必定会创建新的哈希表，导致哈希表的 `size` 和 `sizemask` 变化，而 `key` 的查询与 `sizemask` 有关。因此必须对哈希表中的每一个 `key` 重新计算索引，插入新的哈希表，这个过程称为 `rehash`。过程是这样的：

①：计算新`hash`表的 `realeSize`，值取决于当前要做的是扩容还是收缩：

- 如果是扩容，则新 `size` 为第一个大于等于 `dict.ht[0].used + 1` 的`2^n`

- 如果是收缩，则新 `size` 为第一个大于等于 `dict.ht[0].used` 的 `2^n` （不得小于4）

②：按照新的`realeSize`申请内存空间，创建 `dictht`，并赋值给 `dict.ht[1]`

③：设置 `dict.rehashidx = 0`，标示开始`rehash`

④：将 `dict.ht[0]` 中的每一个 `dictEntry` 都 `rehash` 到 `dict.ht[1]`

⑤：将 `dict.ht[1]` 赋值给  `dict.ht[0]`，给 `dict.ht[1]` 初始化为空哈希表，释放原来的 `dict.ht[0]` 的内存

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240703170359930.png" alt="image-20240703170359930" style="zoom:30%;" />

添加新元素 `k5 = v5`， 扩容后 `rehash` 的结果；

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240703170831692.png" alt="image-20240703170831692" style="zoom:30%;" />

`Dict`的`rehash`并不是一次性完成的。试想一下，如果Dict中包含数百万的`entry`，要在一次`rehash`完成，极有可能导致主线程阻塞。因此Dict的`rehash`是分多次、渐进式的完成，因此称为 **渐进式`rehash`**。流程如下：

针对之前步骤的 第 ④ 步，实际是由以下多步来完成的。

④：将`dict.ht[0]`中的每一个`dictEntry`都`rehash`到`dict.ht[1]`；

每次执行 <font color='red'>新增、查询、修改、删除</font> 操作时，都检查一下 `dict.rehashidx` 是否大于-1，如果是则将 `dict.ht[0].table[rehashidx]` 的 `entry` 链表 `rehash` 到 `dict.ht[1]`，并且将 `rehashidx++`。直至 `dict.ht[0]` 的所有数据都 `rehash` 到 `dict.ht[1]`；

<font color='red'>⑤：将 rehashidx  赋值为 -1，代表 rehash 结束；</font>

<font color='red'>⑥：在 rehash 过程中，新增操作，则直接写入 ht[1]，查询、修改和删除则会在 dict.ht[0] 和 dict.ht[1] 依次查找并执行。这样可以确保 ht[0] 的数据只减不增，随着 rehash 最终为空。</font>



**归纳总结：**

<font color='red'>Dict 的结构：</font>

- 类似 `java` 的 `HashTable`，底层是数组加链表来解决哈希冲突
- `Dict` 包含两个哈希表，`ht[0]`平常用，ht[1]用来rehash

<font color='red'>Dict的伸缩：</font>

- 当`LoadFactor`大于 5 或者 `LoadFactor` 大于 1 并且没有子进程任务时，Dict扩容；
- 当 `LoadFactor` 小于 `0.1` 时，`Dict` 收缩；
- 扩容大小为第一个大于等于 `used + 1` 的 $2^n$ ；
- 收缩大小为第一个大于等于 `used`  的  $2^n$ 
- `Dict` 采用 **渐进式 rehash**，每次访问 `Dict` 时执行一次 `rehash`；
- `rehash` 时 `ht[0]` 只减不增，新增操作只在 `ht[1]` 执行，其它操作在两个哈希表；





### ZipList 部分

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240702130910017.png" alt="image-20240702130910017" style="zoom:40%;" />



<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240702131054689.png" alt="image-20240702131054689" style="zoom:45%;" />

`ZipList` 中的`Entry`并不像普通链表那样记录前后节点的指针，因为记录两个指针要占用16个字节，浪费内存。而是采用了下面的结构：

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240702131159528.png" alt="image-20240702131159528" style="zoom:50%;" />

`previous_entry_length`：前一节点的长度，占 `1` 个或 `5` 个字节。

- 如果前一节点的长度小于 `254` 字节，则采用 `1` 个字节来保存这个长度值；
- 如果前一节点的长度大于 `254` 字节，则采用 `5` 个字节来保存这个长度值，第一个字节为 0xfe，后四个字节才是真实长度数据

`encoding`：编码属性，记录content的数据类型（字符串还是整数）以及长度，占用1个、2个或5个字节

`contents`：负责保存节点的数据，可以是字符串或整数

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240702131421748.png" alt="image-20240702131421748" style="zoom:50%;" />



`ZipListEntry` 中的 `encoding` 编码分为 **字符串** 和 **整数** 两种：

<font color='red'>字符串</font>：如果 `encoding` 是以“00”、“01”或者“10”开头，则证明 `content` 是字符串

|                       **编码**                       | **编码长度** |   **字符串大小**    |
| :--------------------------------------------------: | :----------: | :-----------------: |
|                     \|00pppppp\|                     |   1 bytes    |     <= 63 bytes     |
|                \|01pppppp\|qqqqqqqq\|                |   2 bytes    |   <= 16383 bytes    |
| \|10000000\|qqqqqqqq\|rrrrrrrr\|ssssssss\|tttttttt\| |   5 bytes    | <= 4294967295 bytes |

例如，我们要保存字符串：“ab”和 “bc”

保存 `“ab”`  的 `Entry` 如下：

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240702131548213.png" alt="image-20240702131548213" style="zoom:50%;" />

保存 `“ab”`和 `“bc”` 的 ZipList 如下：

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/image-20240703203605291.png" alt="image-20240703203605291" style="zoom:50%;" />



<font color='red'>整数：</font>

如果 `encoding` 是以 `“11”` 开始，则证明 `content` 是整数，且 `encoding` 固定只占用 1 个字节；



| **编码** | **编码长度** |                         **整数类型**                         |
| :------: | :----------: | :----------------------------------------------------------: |
| 11000000 |      1       |                      int16_t（2 bytes）                      |
| 11010000 |      1       |                      int32_t（4 bytes）                      |
| 11100000 |      1       |                      int64_t（8 bytes）                      |
| 11110000 |      1       |                    24位有符整数(3 bytes)                     |
| 11111110 |      1       |                     8位有符整数(1 bytes)                     |
| 1111xxxx |      1       | 直接在 `xxxx` 位置保存数值，范围从 `0001~1101`，<font color='red'>减 1 后结果为实际值</font> |

例如，一个 `ZipList` 中包含两个整数值：`“2”` 和 `“5”`；

































### String

**① 编码**

字符串对象的编码可以是`int`，`raw` 或者 `embstr`。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1715135139936-d16fceb6-7a04-458d-a654-e7b77df035f0.png" alt="img" style="zoom:35%;" />

1. **int 编码**：保存的是可以用 `long 类型` 表示的整数值。
2. **raw 编码**：保存 **长度大于 44 字节** 的字符串。
3. **embstr 编码**：保存 **长度小于 44 字节** 的字符串。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1715134883589-ad6504df-1eaa-4221-99bb-00dde8eb0dd6.png" alt="img" style="zoom:70%;" />



<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713768308990-c8c186d5-0847-4230-9be2-5e79bf910cf2.png" alt="img" style="zoom:70%;" />

注意，embstr 编码和 raw 编码的边界在 redis 不同版本中是不一样的：

- redis 2.+ 是 32 字节
- redis 3.0-4.0 是 39 字节
- redis 5.0 是 44 字节



可以看到 `embstr` 和 `raw` 编码都会使用 `SDS` 来保存值，但不同之处在于 `embstr` 会通过一次内存分配函数来分配一块连续的内存空间来保存 `redisObject` 和 `SDS`，而 `raw` 编码会通过调用两次内存分配函数来分别分配两块空间来保存 `redisObject` 和 `SDS`。Redis这样做会有很多好处：

- `embstr` 编码将创建字符串对象所需的 **内存分配次数** 从 `raw` 编码的两次降低为一次；
- 释放 `embstr` 编码的字符串对象同样只需要 **调用一次内存释放函数**；
- 因为 `embstr` 编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的 **利用 CPU 缓存提升性能**。



**② 编码的转换**

当 `int` 编码保存的值不再是整数，或大小超过了 `long` 的范围时，自动转化为 `raw`。

对于 embstr 编码，由于 Redis 没有对其编写任何的修改程序（**embstr 是只读的**），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。



### List

**① 编码**

可以是  **ziplist(压缩列表)** 和 **linkedlist(双端链表)**

**ziplist 编码表示如下：**

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713768398351-c76fa85a-e77f-4cf6-9069-bc3571296db6.png" alt="img" style="zoom:75%;" />

**linkedlist 表示如下：**

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713768420526-e88aafd1-8a2e-41f0-8da6-e99414761faa.png" alt="img" style="zoom:75%;" />

**② 编码转换**

当同时满足下面两个条件时，使用 **ziplist** 编码：

1、列表保存元素个数小于 **512 个**

2、每个元素长度小于 **64 字节**

不能满足这两个条件的时候使用 **linkedlist** 编码。

上面两个条件可以在redis.conf 配置文件中的 `list-max-ziplist-value` 选项和 `list-max-ziplist-entries` 选项进行配置。



但是 **在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表**。



### Hash 

**① 编码**

 哈希对象的编码可以是 **ziplist** 或者 **hashtable**。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1715136287107-527604d8-f444-4191-b728-ae07deb2af79.png" alt="img" style="zoom:70%;" />



<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1715136320115-630bd226-65b3-4cf5-b779-c4341c3767ad.png" alt="img" style="zoom:65%;" />

`hashtable` 编码的哈希表对象底层使用字典数据结构，哈希对象中的每个键值对都使用一个字典键值对。

在前面介绍压缩列表时，我们介绍过压缩列表是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，相对于字典数据结构，压缩列表用于元素个数少、元素长度小的场景。其优势在于集中存储，节省空间。

**② 编码转换**

1. 列表保存元素个数 **小于512个**
2. 每个元素长度 **小于64字节**

不能满足这两个条件的时候使用 **hashtable 编码**。第一个条件可以通过配置文件中的 `set-max-intset-entries` 进行修改。

**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了**。



### Set

**① 编码**

**intset** 或者 **hashtable**。

`intset` 编码的集合对象使用 `整数集合` 作为底层实现，集合对象包含的所有元素都被保存在整数集合中。

`hashtable` 编码的集合对象使用 `字典` 作为底层实现，字典的每个键都是一个字符串对象，这里的每个字符串对象就是一个集合中的元素，而字典的值则全部设置为 null。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1715136721254-4fcccd72-e074-4648-8e33-6e1dd07113b7.png" alt="img" style="zoom:80%;" />



<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1715136771064-1a3f10d4-93e5-453f-8120-e31c854bfcec.png" alt="img" style="zoom:80%;" />

当集合同时满足以下两个条件时，使用 intset 编码：

1. 集合对象中 **所有元素都是整数**
2. 集合对象所有元素 **数量不超过512**

不能满足这两个条件的就使用 hashtable 编码。第二个条件可以通过配置文件的`set-max-intset-entries` 进行配置。



### Zset

有序集合的编码可以是 `ziplist` 或者 `skiplist`。

**skiplist** 编码的有序集合对象使用 zset 结构作为底层实现，一个 zset 结构同时包含一个字典和一个跳跃表：

```java
typedef struct zset{
   //跳跃表
	 zskiplist *zsl;
   //字典
   dict *dice;
} zset;
```

字典的键保存元素的值，字典的值则保存元素的分值；跳跃表节点的 object 属性保存元素的成员，跳跃表节点的 score 属性保存元素的分值。



其实有序集合 **单独使用字典或跳跃表** 其中一种数据结构都可以实现，但是这里使用两种数据结构组合起来，原因是假如我们单独**使用字典，虽然能以 O(1) 的时间复杂度查找成员的分值**，但是因为**字典是以无序的方式来保存集合元素，所以每次进行范围操作的时候都要进行排序**；假如我们单独使用跳跃表来实现，虽然能执行范围操作，但是 **查找操作有 O(1)的复杂度变为了O(logN)**。因此 Redis 使用了两种数据结构来共同实现有序集合。
