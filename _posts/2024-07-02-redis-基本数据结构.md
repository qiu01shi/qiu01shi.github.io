---
layout: post
title: Redis 基本数据结构
date: 2024-07-02 11:38 +0800
categories: [Blogging,Redis]
author: <author_id>  
---

## 基本数据类型

### String

**字符串类型**，是redis中最基本的数据类型，一个 `key` 对应一个 `value`。

`String` 类型是 **二进制安全** 的，意思是 redis 的 string 可以包含任何数据。如数字，字符串，jpg图片或者序列化的对象。

**使用**：`get` 、`set`、`del`、`incr`、`decr` 等

**实战场景：**

1. 缓存： 经典使用场景，把常用信息，字符串，图片或者视频等信息放到redis中，redis作为缓存层，mysql做持久化层，降低mysql 的读写压力。
2. 计数器：redis是单线程模型，一个命令执行完才会执行下一个，同时数据可以一步落地到其他的数据源。
3. session：常见方案 spring session + redis 实现session共享，



### List

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713767398240-5ffe163a-1772-4caf-ba9e-95c48cea5d5c-20240702114043627.png" alt="img" style="zoom:80%;" />

**使用双端链表实现** `List`**，有序的，**`value` **可以重复，**可以通过下标取出对应的 value 值，左右两边都能进行插入和删除数据。

**实战场景：**

- timeline：例如微博的时间轴，有人发布微博，用 `lpush` 加入时间轴，展示新的列表信息。



### Hash

**哈希类型**，是一个 `Mapmap`，指值本身又是一种键值对结构。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713767319569-40f1112c-4926-41be-a7d1-a6b38599934b.png" alt="img" style="zoom:80%;" />



使用：所有hash的命令都是 h 开头的 `hget`、`hset` 、`hdel` 等

**实战场景：**

- 缓存： 能直观，相比string更节省空间，的维护缓存信息，如用户信息，视频信息等。



### Set

集合类型也是用来保存多个字符串的元素，但和列表不同的是集合中 

1. **不允许有重复的元素**；
2. 集合中的 **元素是无序的**，不能通过索引下标获取元素，
3. 支持 **集合间的操作**，可以取多个集合取交集、并集、差集。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713767544186-63000669-dcb7-4143-a066-ed399eb77697.png" alt="img" style="zoom:60%;" />

**实战场景：**

1. 标签（tag）,给用户添加标签，或者用户给消息添加标签，这样有同一标签或者类似标签的可以给推荐关注的事或者关注的人；
2. 点赞，或点踩，收藏等，可以放到set中实现。

### Zset

有序集合和集合有着必然的联系，保留了集合不能有重复成员的特性，区别是，有序集合中的元素是可以排序的，它 `给每个元素设置一个分数`，作为排序的依据。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713767621333-9ee948fc-d508-433d-9146-6932e9c63264.png" alt="img" style="zoom:60%;" />



## 基本数据类型的底层实现

### 对象的类型与编码

`Redis` 使用前面说的五大数据类型来表示键和值，每次在 `Redis` 数据库中创建一个键值对时，至少会创建两个对象，一个是 **键对象**，一个是 **值对象**，而`Redis`中的每个对象都是由`redisObject`结构来表示：

```java
typedef struct redisObject{
   unsigned type:4;   	//类型
   unsigned encoding:4;   //编码
   void *ptr;   	//指向底层数据结构的指针
   int refcount;   	//引用计数
   unsigned lru:22;	 	//记录最后一次被程序访问的时间
}robj
```

① **type属性**

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713767982048-ecccd52a-ca63-420b-8478-b203d5d447c7.png" alt="img" style="zoom:70%;" />

在Redis中，**键总是一个字符串对象**，而 **值可以是字符串、列表、集合等对象**，所以我们通常说的键为字符串键，表示的是这个键对应的值为字符串对象，我们说一个键为集合键时，表示的是这个键对应的值为集合对象。



**② encoding 属性和** `prt` **指针**

对象的 prt 指针指向对象底层的数据结构，而 **数据结构由 encoding 属性** 来决定。

<img src="https://cdn.nlark.com/yuque/0/2024/png/29452643/1713768123116-6060c1ff-672a-45eb-80a5-bc1d35ad9952.png" alt="img" style="zoom:70%;" />

而每种类型的对象都至少使用了两种不同的编码：

<img src="https://cdn.nlark.com/yuque/0/2024/png/29452643/1713768193628-504c2497-6bf1-4c1e-9dfe-fcf7e8154894.png" alt="img" style="zoom:70%;" />

简单来说，底层数据结构一共有6种，分别是 **简单动态字符串**、**双向链表**、**压缩列表**、**哈希表**、**跳表** 和 **整数数组**。它们和数据类型的对应关系如下图所示：

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/88f2621e-44bd-47a4-8e03-8e1e94664d0d.jpg" alt="88f2621e-44bd-47a4-8e03-8e1e94664d0d" style="zoom:15%;" />

### String

**① 编码**

字符串对象的编码可以是`int`，`raw` 或者 `embstr`。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1715135139936-d16fceb6-7a04-458d-a654-e7b77df035f0.png" alt="img" style="zoom:35%;" />

1. **int 编码**：保存的是可以用 `long 类型` 表示的整数值。
2. **raw 编码**：保存 **长度大于 44 字节** 的字符串。
3. **embstr 编码**：保存 **长度小于 44 字节** 的字符串。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1715134883589-ad6504df-1eaa-4221-99bb-00dde8eb0dd6.png" alt="img" style="zoom:70%;" />



<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713768308990-c8c186d5-0847-4230-9be2-5e79bf910cf2.png" alt="img" style="zoom:70%;" />

注意，embstr 编码和 raw 编码的边界在 redis 不同版本中是不一样的：

- redis 2.+ 是 32 字节
- redis 3.0-4.0 是 39 字节
- redis 5.0 是 44 字节



可以看到 `embstr` 和 `raw` 编码都会使用 `SDS` 来保存值，但不同之处在于 `embstr` 会通过一次内存分配函数来分配一块连续的内存空间来保存 `redisObject` 和 `SDS`，而 `raw` 编码会通过调用两次内存分配函数来分别分配两块空间来保存 `redisObject` 和 `SDS`。Redis这样做会有很多好处：

- `embstr` 编码将创建字符串对象所需的 **内存分配次数** 从 `raw` 编码的两次降低为一次；
- 释放 `embstr` 编码的字符串对象同样只需要 **调用一次内存释放函数**；
- 因为 `embstr` 编码的字符串对象的所有数据都保存在一块连续的内存里面可以更好的 **利用 CPU 缓存提升性能**。



**② 编码的转换**

当 `int` 编码保存的值不再是整数，或大小超过了 `long` 的范围时，自动转化为 `raw`。

对于 embstr 编码，由于 Redis 没有对其编写任何的修改程序（**embstr 是只读的**），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。



### List

**① 编码**

可以是  **ziplist(压缩列表)** 和 **linkedlist(双端链表)**

**ziplist 编码表示如下：**

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713768398351-c76fa85a-e77f-4cf6-9069-bc3571296db6.png" alt="img" style="zoom:75%;" />

**linkedlist 表示如下：**

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1713768420526-e88aafd1-8a2e-41f0-8da6-e99414761faa.png" alt="img" style="zoom:75%;" />

**② 编码转换**

当同时满足下面两个条件时，使用 **ziplist** 编码：

1、列表保存元素个数小于 **512 个**

2、每个元素长度小于 **64 字节**

不能满足这两个条件的时候使用 **linkedlist** 编码。

上面两个条件可以在redis.conf 配置文件中的 `list-max-ziplist-value` 选项和 `list-max-ziplist-entries` 选项进行配置。



但是 **在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表**。



### Hash 

**① 编码**

 哈希对象的编码可以是 **ziplist** 或者 **hashtable**。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1715136287107-527604d8-f444-4191-b728-ae07deb2af79.png" alt="img" style="zoom:70%;" />



<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1715136320115-630bd226-65b3-4cf5-b779-c4341c3767ad.png" alt="img" style="zoom:65%;" />

`hashtable` 编码的哈希表对象底层使用字典数据结构，哈希对象中的每个键值对都使用一个字典键值对。

在前面介绍压缩列表时，我们介绍过压缩列表是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，相对于字典数据结构，压缩列表用于元素个数少、元素长度小的场景。其优势在于集中存储，节省空间。

**② 编码转换**

1. 列表保存元素个数 **小于512个**
2. 每个元素长度 **小于64字节**

不能满足这两个条件的时候使用 **hashtable 编码**。第一个条件可以通过配置文件中的 `set-max-intset-entries` 进行修改。

**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了**。



### Set

**① 编码**

**intset** 或者 **hashtable**。

`intset` 编码的集合对象使用 `整数集合` 作为底层实现，集合对象包含的所有元素都被保存在整数集合中。

`hashtable` 编码的集合对象使用 `字典` 作为底层实现，字典的每个键都是一个字符串对象，这里的每个字符串对象就是一个集合中的元素，而字典的值则全部设置为 null。

<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1715136721254-4fcccd72-e074-4648-8e33-6e1dd07113b7.png" alt="img" style="zoom:80%;" />



<img src="../media/2024-07-02-redis-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1715136771064-1a3f10d4-93e5-453f-8120-e31c854bfcec.png" alt="img" style="zoom:80%;" />

当集合同时满足以下两个条件时，使用 intset 编码：

1. 集合对象中 **所有元素都是整数**
2. 集合对象所有元素 **数量不超过512**

不能满足这两个条件的就使用 hashtable 编码。第二个条件可以通过配置文件的`set-max-intset-entries` 进行配置。



### Zset

有序集合的编码可以是 `ziplist` 或者 `skiplist`。

**skiplist** 编码的有序集合对象使用 zset 结构作为底层实现，一个 zset 结构同时包含一个字典和一个跳跃表：

```java
typedef struct zset{
   //跳跃表
	 zskiplist *zsl;
   //字典
   dict *dice;
} zset;
```

字典的键保存元素的值，字典的值则保存元素的分值；跳跃表节点的 object 属性保存元素的成员，跳跃表节点的 score 属性保存元素的分值。



其实有序集合 **单独使用字典或跳跃表** 其中一种数据结构都可以实现，但是这里使用两种数据结构组合起来，原因是假如我们单独**使用字典，虽然能以 O(1) 的时间复杂度查找成员的分值**，但是因为**字典是以无序的方式来保存集合元素，所以每次进行范围操作的时候都要进行排序**；假如我们单独使用跳跃表来实现，虽然能执行范围操作，但是 **查找操作有 O(1)的复杂度变为了O(logN)**。因此 Redis 使用了两种数据结构来共同实现有序集合。
