---
layout: post
title: 动态规划：0-1 背包与完全背包
date: 2024-07-04 14:21 +0800
categories: [算法分析,动态规划]
author: <author_id>  
---

## 0-1 背包 问题

以 [494. 目标和](https://leetcode.cn/problems/target-sum/) 为例，对 `0-1` 背包进行分析！

### **一：记忆化搜索**

整体转换思路如下：

设  `p` 表示正数总数值，则 `s - p` 为 负数总数值，则有 `p - (s - p) = t`，也即：` 2p - s = t  =〉 p = (s + t) / 2   `  实现问题的转换。

```java
public class Solution {            
    private int[] nums;
    private int[][] memo;

    public int findTargetSumWays(int[] nums, int target) {
        this.nums = nums;
        int sum = Arrays.stream(nums).sum();
        target += sum; // 调整目标值
        if (target < 0 || target % 2 != 0) {
            return 0;
        }
        target /= 2; // 目标值除以2
        int n = nums.length;
        this.memo = new int[n][target + 1];
        for(int[] row : memo){
            Arrays.fill(row, -1);   // -1 表示没有计算过
        }
        return dfs(n - 1, target);
    }

    private int dfs(int i, int c) {
        if (i < 0) {
            return c == 0 ? 1 : 0;
        }
        if (memo[i][c] != -1) { // 之前计算过
            return memo[i][c];
        }
        if (c < nums[i]) {
            return memo[i][c] = dfs(i - 1, c); // 只能不选
        } else {
            // 不选 + 选 的情况
            return memo[i][c] = dfs(i - 1, c) + dfs(i - 1, c - nums[i]);
        }
    }
}
```

### 二：递推 — 二维数组

- **时间复杂度：**O(*nm*)，其中 *n* 为 *nums* 的长度，*m* 为 *nums* 的元素和减去 *target* 的绝对值。
- **空间复杂度：**O(*nm*)。

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = Arrays.stream(nums).sum();
        target += sum;
        if (target < 0 || target % 2 != 0) {
            return 0;
        }
        target /= 2;

        int n = nums.length;
        int[][] f = new int[n + 1][target + 1];
        f[0][0] = 1; // 初始化

        for (int i = 0; i < n; i++) {
            int x = nums[i];
            for (int c = 0; c <= target; c++) {
                if (c < x) {
                    f[i + 1][c] = f[i][c]; // 如果当前目标值小于当前数字，不选择当前数字
                } else {
                    f[i + 1][c] = f[i][c] + f[i][c - x]; // 选择或不选择当前数字
                }
            }
        }

        return f[n][target]; // 返回结果
    }
}
```

### 三：空间优化 — 两个二维数组元素

- 时间复杂度：O(*nm*)，其中 *n* 为 *nums* 的长度，*m* 为 *nums* 的元素和减去 *target* 的绝对值。
- 空间复杂度：O(*m*)。

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = Arrays.stream(nums).sum();
        target += sum;
        if (target < 0 || target % 2 != 0) {
            return 0;
        }
        target /= 2;

        int n = nums.length;
        int[][] f = new int[2][target + 1];
        f[0][0] = 1; // 初始化

        for (int i = 0; i < n; i++) {
            int x = nums[i];
            for (int c = 0; c <= target; c++) {
                if (c < x) {
                    f[(i + 1) % 2][c] = f[i % 2][c]; // 不选择当前数字
                } else {
                    f[(i + 1) % 2][c] = f[i % 2][c] + f[i % 2][c - x]; // 选择或不选择当前数字
                }
            }
        }

        return f[n % 2][target]; // 返回结果
    }
}
```

### 四：空间优化 — 一维数组

- 时间复杂度：O(*nm*)，其中 *n* 为 *nums* 的长度，*m* 为 *nums* 的元素和减去 *target* 的绝对值。
- 空间复杂度：O(*m*)。

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = Arrays.stream(nums).sum();
        target += sum;
        if (target < 0 || target % 2 != 0) {
            return 0;
        }
        target /= 2;

        int n = nums.length;
        int[] f = new int[target + 1];
        f[0] = 1; // 初始化

        for (int x : nums) {
            for (int c = target; c >= x; c--) {
                f[c] = f[c] + f[c - x]; // 更新状态
            }
        }

        return f[target]; // 返回结果
    }
}
```



## 完全背包问题

以 [322. 零钱兑换](https://leetcode.cn/problems/coin-change/) 为例，对完全背包进行分析！

### 一：记忆化搜索

- **时间复杂度：**O(*n*⋅*amount*)，其中 *n* 为 *coins* 的长度。
- **空间复杂度：**O(*n*⋅*amount*)。

```java
class Solution {
    private int[] coins; // 存储硬币面值的数组
    private int[][] memo; // 记忆化数组，存储中间结果

    public int coinChange(int[] coins, int amount) {
        this.coins = coins;
        // 硬币数量
        int n = coins.length; 
        // 初始化记忆化数组
        memo = new int[n][amount + 1]; 
        for (int[] row : memo) {
            // 将记忆化数组的每一行初始化为-1，表示没有访问过
            Arrays.fill(row, -1); 
        }
        int ans = dfs(n - 1, amount); // 开始深度优先搜索
        
        // 如果结果小于 Integer.MAX_VALUE / 2，返回结果，否则返回-1，表示无法组成该金额
        return ans < Integer.MAX_VALUE / 2 ? ans : -1; 
    }

    private int dfs(int i, int c) {
        if (i < 0) { // 如果没有硬币可选
            // 如果金额为0，返回0，否则返回无穷大的一半，防止溢出
            return c == 0 ? 0 : Integer.MAX_VALUE / 2; 
        }
        if (memo[i][c] != -1) { // 检查是否已有记忆化结果
            return memo[i][c];
        }
        if (c < coins[i]) { // 如果当前金额小于当前硬币面值
            return memo[i][c] = dfs(i - 1, c); // 不选择当前硬币
        }

        // 选择或不选择当前硬币，取较小值
        return memo[i][c] = Math.min(dfs(i - 1, c), dfs(i, c - coins[i]) + 1); 
    }
}
```

### 二：递推 — 二维数组

- **时间复杂度：**O(*n*⋅*amount*)，其中 *n* 为 *coins* 的长度。
- **空间复杂度：**O(*n*⋅*amount*)。

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int n = coins.length;
        int[][] f = new int[n + 1][amount + 1];
        Arrays.fill(f[0], Integer.MAX_VALUE / 2); // 除 2 防止下面 + 1 溢出
        f[0][0] = 0;
        for (int i = 0; i < n; i++) {
            for (int c = 0; c <= amount; c++) {
                if (c < coins[i]) f[i + 1][c] = f[i][c];
                else f[i + 1][c] = Math.min(f[i][c], f[i + 1][c - coins[i]] + 1);
            }
        }
        int ans = f[n][amount];
        return ans < Integer.MAX_VALUE / 2 ? ans : -1;
    }
}
```



### 三：空间优化 — 两个二维数组元素

- **时间复杂度：**O(*n*⋅*amount*)，其中 *n* 为 *coins* 的长度。
- **空间复杂度：**O(*amount*)。

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int n = coins.length;
        int[][] f = new int[2][amount + 1];
        Arrays.fill(f[0], Integer.MAX_VALUE / 2);
        f[0][0] = 0;
        for (int i = 0; i < n; i++) {
            for (int c = 0; c <= amount; c++) {
                if (c < coins[i]) f[(i + 1) % 2][c] = f[i % 2][c];
                else f[(i + 1) % 2][c] = Math.min(f[i % 2][c], f[(i + 1) % 2][c - coins[i]] + 1);
            }
        }
        int ans = f[n % 2][amount];
        return ans < Integer.MAX_VALUE / 2 ? ans : -1;
    }
}
```



### 四：空间优化 — 一维数组

- **时间复杂度：**O(*n*⋅*amount*)，其中 *n* 为 *coins* 的长度。
- **空间复杂度：**O(*amount*)。

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] f = new int[amount + 1];
        Arrays.fill(f, Integer.MAX_VALUE / 2);
        f[0] = 0;
        for (int x : coins) {
            for (int c = x; c <= amount; c++) {
                f[c] = Math.min(f[c], f[c - x] + 1);
            }
        }
        int ans = f[amount];
        return ans < Integer.MAX_VALUE / 2 ? ans : -1;
    }
}
```
