---
layout: post
title: 动态规划：0-1 背包与完全背包
date: 2024-07-04 14:21 +0800
categories: [算法分析,动态规划]
author: <author_id>  
---

## 动态规划基础：0-1 背包与完全背包

以 [494. 目标和](https://leetcode.cn/problems/target-sum/) 为例，对 `0-1` 背包进行分析：

### **一：记忆化搜索 —— 选与不选逻辑 + 保存结果**

整体转换思路如下：

设  `p` 表示正数总数值，则 `s - p` 为 负数总数值，则有 `p - (s - p) = t`，也即：` 2p - s = t  =〉 p = (s + t) / 2   `  实现问题的转换。

```java
public class Solution {            
    private int[] nums;
    private int[][] memo;

    public int findTargetSumWays(int[] nums, int target) {
        this.nums = nums;
        int sum = Arrays.stream(nums).sum();
        target += sum; // 调整目标值
        if (target < 0 || target % 2 != 0) {
            return 0;
        }
        target /= 2; // 目标值除以2
        int n = nums.length;
        this.memo = new int[n][target + 1];
        for(int[] row : memo){
            Arrays.fill(row, -1);   // -1 表示没有计算过
        }
        return dfs(n - 1, target);
    }

    private int dfs(int i, int c) {
        if (i < 0) {
            return c == 0 ? 1 : 0;
        }
        if (memo[i][c] != -1) { // 之前计算过
            return memo[i][c];
        }
        if (c < nums[i]) {
            return memo[i][c] = dfs(i - 1, c); // 只能不选
        } else {
            // 不选 + 选 的情况
            return memo[i][c] = dfs(i - 1, c) + dfs(i - 1, c - nums[i]);
        }
    }
}
```

### 二：递推 —— 二维数组

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = Arrays.stream(nums).sum();
        target += sum;
        if (target < 0 || target % 2 != 0) {
            return 0;
        }
        target /= 2;

        int n = nums.length;
        int[][] f = new int[n + 1][target + 1];
        f[0][0] = 1; // 初始化

        for (int i = 0; i < n; i++) {
            int x = nums[i];
            for (int c = 0; c <= target; c++) {
                if (c < x) {
                    f[i + 1][c] = f[i][c]; // 如果当前目标值小于当前数字，不选择当前数字
                } else {
                    f[i + 1][c] = f[i][c] + f[i][c - x]; // 选择或不选择当前数字
                }
            }
        }

        return f[n][target]; // 返回结果
    }
}
```

### 三：空间优化 —— 两个二维数组元素

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = Arrays.stream(nums).sum();
        target += sum;
        if (target < 0 || target % 2 != 0) {
            return 0;
        }
        target /= 2;

        int n = nums.length;
        int[][] f = new int[2][target + 1];
        f[0][0] = 1; // 初始化

        for (int i = 0; i < n; i++) {
            int x = nums[i];
            for (int c = 0; c <= target; c++) {
                if (c < x) {
                    f[(i + 1) % 2][c] = f[i % 2][c]; // 不选择当前数字
                } else {
                    f[(i + 1) % 2][c] = f[i % 2][c] + f[i % 2][c - x]; // 选择或不选择当前数字
                }
            }
        }

        return f[n % 2][target]; // 返回结果
    }
}
```

### 四：空间优化 —— 一纬数组

```java
class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int sum = Arrays.stream(nums).sum();
        target += sum;
        if (target < 0 || target % 2 != 0) {
            return 0;
        }
        target /= 2;

        int n = nums.length;
        int[] f = new int[target + 1];
        f[0] = 1; // 初始化

        for (int x : nums) {
            for (int c = target; c >= x; c--) {
                f[c] = f[c] + f[c - x]; // 更新状态
            }
        }

        return f[target]; // 返回结果
    }
}
```













