---
layout: post
title: 项目基本环境与介绍
date: 2024-06-25 21:44 +0800
categories: [TJU-news]
author: <author_id>
---

- 主要实现的功能：登录及网关认证校验

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625215226560.png" alt="image-20240625215226560" style="zoom:40%;" />

- 目标：接口测试工具及前后端联调



<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625215340402.png" alt="image-20240625215340402" style="zoom:40%;" />

## 项目技术栈

基础层：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625215429943.png" alt="image-20240625215429943" style="zoom:35%;" />

服务层：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625215529989.png" alt="image-20240625215529989" style="zoom:35%;" />



## Nacos

Nacos 安装过程如下：

①：docker拉取镜像 

```shell
docker pull nacos/nacos-server:1.2.0
```

②：创建容器

```shell
docker run --env MODE=standalone --name nacos --restart=always  -d -p 8848:8848 nacos/nacos-server:1.2.0
```

- MODE=standalone 单机版

- --restart=always 开机启动

- -p 8848:8848  映射端口

- -d 创建一个守护式容器在后台运行

③：访问地址：http://localhost:8848/nacos 

## 初始工程搭建

**项目依赖环境：**

- JDK1.8

- Intellij Idea

- maven-3.6.1
- Git



**工程主题结构：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625220234725.png" alt="image-20240625220234725" style="zoom:35%;" />



**全局异常处理：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625220555896.png" alt="image-20240625220555896" style="zoom:35%;" />



## APP 登录

- 用户点击开始使用

	登录后的用户权限较大，可以查看，也可以操作（点赞，关注，评论）



- 用户点击不登录，先看看

	游客只有查看的权限

	<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625221306461.png" alt="image-20240625221306461" style="zoom:40%;" />

### 表结构分析

关于 app 端用户相关的内容较多，单独设置一个库 `leadnews_user` 用于存储

|    **表名称**    |      **说明**      |
| :--------------: | :----------------: |
|     ap_user      |   APP 用户信息表   |
|   ap_user_fan    | APP 用户粉丝信息表 |
|  ap_user_follow  | APP 用户关注信息表 |
| ap_user_realname | APP 实名认证信息表 |

登录需要用到的是 `ap_user` 表，表结构如下：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625224341998.png" alt="image-20240625224341998" style="zoom:40%;" />

⚠️ 注意事项：

- `tinyint` 类型：占 1 个字节，不指定 unsigned (非负数)，值范围 (-128,127)，指定了 unsigned，值范围 (0,255)

- `tinyint` 通常表示小范围的数值，或者表示 `true` 或 `false`，通常值为 0 表示 `false`,值为 1 表示 `true`；

项目中的持久层使用的 `mybatis-plus`，一般都使用 `mybais-plus` 逆向生成对应的实体类。

app_user 表对应的实体类如下：

```java
@Data
@TableName("ap_user")
public class ApUser implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 主键
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    /**
     * 密码、通信等加密盐
     */
    @TableField("salt")
    private String salt;

    /**
     * 用户名
     */
    @TableField("name")
    private String name;

    /**
     * 密码,md5加密
     */
    @TableField("password")
    private String password;

    /**
     * 手机号
     */
    @TableField("phone")
    private String phone;

    /**
     * 头像
     */
    @TableField("image")
    private String image;

    /**
     * 0 男
            1 女
            2 未知
     */
    @TableField("sex")
    private Boolean sex;

    /**
     * 0 未
            1 是
     */
    @TableField("is_certification")
    private Boolean certification;

    /**
     * 是否身份认证
     */
    @TableField("is_identity_authentication")
    private Boolean identityAuthentication;

    /**
     * 0正常
            1锁定
     */
    @TableField("status")
    private Boolean status;

    /**
     * 0 普通用户
            1 自媒体人
            2 大V
     */
    @TableField("flag")
    private Short flag;

    /**
     * 注册时间
     */
    @TableField("created_time")
    private Date createdTime;

}
```



### 手动加密

具体采用 md5 + 随机字符串 实现；

`md5` 是不可逆加密，`md5` 相同的密码每次加密都一样，不太安全。在 `md5` 的基础上手动加盐（salt）处理；



**注册 —> 生成盐：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625224441208.png" alt="image-20240625224441208" style="zoom:35%;" />

**登录 —> 使用盐来配合验证：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625224614946.png" alt="image-20240625224614946" style="zoom:35%;" />



**用户访问流程：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625224814630.png" alt="image-20240625224814630" style="zoom:35%;" />

- 用户输入了用户名和密码进行登录，校验成功后返回 `jwt`（基于当前用户的id生成）；
- 用户游客登录，生成 `jwt` 返回（基于默认值0生成）；



### 项目配置

`TJU-campus-service` 依赖信息说明

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625225912387.png" alt="image-20240625225912387" style="zoom:45%;" />

在 `TJU-campus-service` 下创建工程 `TJU-campus-user`：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625230838045.png" alt="image-20240625230838045" style="zoom:45%;" />

引导类：

```java
@SpringBootApplication
@EnableDiscoveryClient
@MapperScan("com.shawen.user.mapper")
public class UserApplication {

    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class,args);
    }
}
```

bootstrap.yml

```java
server:
  port: 51801
spring:
  application:
    name: leadnews-user
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
      config:
        server-addr: localhost:8848
        file-extension: yml
```

在 `nacos` 中创建配置文件：

```yaml
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/leadnews_user?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC&useSSL=false
    username: ****
    password: ****
# 设置Mapper接口所对应的XML文件位置，如果你在Mapper接口中有自定义方法，需要进行该配置
mybatis-plus:
  mapper-locations: classpath*:mapper/*.xml
  # 设置别名包扫描路径，通过该属性可以给包中的类注册别名
  type-aliases-package: com.shawen.model.user.pojos
```

`logback.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>

<configuration>
    <!--定义日志文件的存储地址,使用绝对路径-->
    <property name="LOG_HOME" value="logs"/>

    <!-- Console 输出设置 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            <charset>utf8</charset>
        </encoder>
    </appender>

    <!-- 按照每天生成日志文件 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--日志文件输出的文件名-->
            <fileNamePattern>${LOG_HOME}/leadnews.%d{yyyy-MM-dd}.log</fileNamePattern>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 异步输出 -->
    <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
        <!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 -->
        <discardingThreshold>0</discardingThreshold>
        <!-- 更改默认的队列的深度,该值会影响性能.默认值为256 -->
        <queueSize>512</queueSize>
        <!-- 添加附加的appender,最多只能添加一个 -->
        <appender-ref ref="FILE"/>
    </appender>


    <logger name="org.apache.ibatis.cache.decorators.LoggingCache" level="DEBUG" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>
    <logger name="org.springframework.boot" level="debug"/>
    <root level="info">
        <!--<appender-ref ref="ASYNC"/>-->
        <appender-ref ref="FILE"/>
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
```



### 接口文档

|          |         **说明**         |
| :------: | :----------------------: |
| 接口路径 | /api/v1/login/login_auth |
| 请求方式 |           POST           |
|   参数   |         LoginDto         |
| 响应结果 |      ResponseResult      |

**LoginDTO：**

```java
@Data
public class LoginDto {

    /**
     * 手机号
     */
    @ApiModelProperty(value = "手机号",required = true)
    private String phone;

    /**
     * 密码
     */
    @ApiModelProperty(value = "密码",required = true)
    private String password;
}
```

**ResponseResult：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626093406777.png" alt="image-20240626093406777" style="zoom:45%;" />

### 代码实现

①：控制层controller

```java
@RestController
@RequestMapping("/api/v1/login")
@Api(value = "app端用户登录",tags = "app端用户登录")
public class ApUserLoginController {

    @Autowired
    private ApUserService apUserService;

    @PostMapping("/login_auth")
    @ApiOperation("用户登录")
    public ResponseResult login(@RequestBody LoginDto dto){
        return apUserService.login(dto);
    }
}
```

②：持久层mapper

```java
@Mapper
public interface ApUserMapper extends BaseMapper<ApUser> {
}
```

③：业务层service

```java
public interface ApUserService extends IService<ApUser> {
    /**
     * app端登录功能
     * @param dto
     * @return
     */
    public ResponseResult login(LoginDto dto);
}
```

④：实现类

```java
@Service
@Transactional
@Slf4j
public class ApUserServiceImpl extends ServiceImpl<ApUserMapper, ApUser> implements ApUserService {
    /**
     * app端登录功能
     * @param dto
     * @return
     */
    @Override
    public ResponseResult login(LoginDto dto) {
        //1.正常登录 用户名和密码
        if(StringUtils.isNotBlank(dto.getPhone()) && StringUtils.isNotBlank(dto.getPassword())){
            //1.1 根据手机号查询用户信息
            ApUser dbUser = getOne(Wrappers.<ApUser>lambdaQuery()
                                   .eq(ApUser::getPhone, dto.getPhone()));
            if(dbUser == null){
                return ResponseResult.errorResult(AppHttpCodeEnum.DATA_NOT_EXIST,"用户信息不存在");
            }

            //1.2 比对密码
            String salt = dbUser.getSalt();
            String password = dto.getPassword();
            String pswd = DigestUtils.md5DigestAsHex((password + salt).getBytes());
            if(!pswd.equals(dbUser.getPassword())){
                return ResponseResult.errorResult(AppHttpCodeEnum.LOGIN_PASSWORD_ERROR);
            }

            //1.3 返回数据  jwt  user
            String token = AppJwtUtil.getToken(dbUser.getId().longValue());
            Map<String,Object> map = new HashMap<>();
            map.put("token",token);
            dbUser.setSalt("");
            dbUser.setPassword("");
            map.put("user",dbUser);

            return ResponseResult.okResult(map);
        }else {
            //2.游客登录
            Map<String,Object> map = new HashMap<>();
            map.put("token",AppJwtUtil.getToken(0L));
            return ResponseResult.okResult(map);
        }
    }
}
```



## APP 端网关

### 网关概述

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626093703868.png" alt="image-20240626093703868" style="zoom:40%;" />

项目中网关服务的工程结构：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626093932168.png" alt="image-20240626093932168" style="zoom:45%;" />

###  jwt 校验

流程：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626094041322.png" alt="image-20240626094041322" style="zoom:40%;" />





## app前端项目集成

`nginx` 配置：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626094224696.png" alt="image-20240626094224696" style="zoom:40%;" />





































