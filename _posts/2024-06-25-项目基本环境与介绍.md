---
layout: post
title: 项目基本环境与介绍
date: 2024-06-25 21:44 +0800
categories: [TJU-news]
author: <author_id>
---

- 主要实现的功能：登录及网关认证校验

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625215226560.png" alt="image-20240625215226560" style="zoom:40%;" />

- 目标：接口测试工具及前后端联调



<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625215340402.png" alt="image-20240625215340402" style="zoom:40%;" />

## 项目技术栈

基础层：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625215429943.png" alt="image-20240625215429943" style="zoom:35%;" />

服务层：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625215529989.png" alt="image-20240625215529989" style="zoom:35%;" />



## Nacos

Nacos 安装过程如下：

①：docker拉取镜像 

```shell
docker pull nacos/nacos-server:1.2.0
```

②：创建容器

```shell
docker run --env MODE=standalone --name nacos --restart=always  -d -p 8848:8848 nacos/nacos-server:1.2.0
```

- MODE=standalone 单机版

- --restart=always 开机启动

- -p 8848:8848  映射端口

- -d 创建一个守护式容器在后台运行

③：访问地址：http://localhost:8848/nacos 

## 初始工程搭建

**项目依赖环境：**

- JDK1.8

- Intellij Idea

- maven-3.6.1
- Git



**工程主题结构：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625220234725.png" alt="image-20240625220234725" style="zoom:35%;" />



**全局异常处理：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625220555896.png" alt="image-20240625220555896" style="zoom:35%;" />



## APP 登录

- 用户点击开始使用

	登录后的用户权限较大，可以查看，也可以操作（点赞，关注，评论）



- 用户点击不登录，先看看

	游客只有查看的权限

	<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625221306461.png" alt="image-20240625221306461" style="zoom:40%;" />

### 表结构分析

关于 app 端用户相关的内容较多，单独设置一个库 `leadnews_user` 用于存储

|    **表名称**    |      **说明**      |
| :--------------: | :----------------: |
|     ap_user      |   APP 用户信息表   |
|   ap_user_fan    | APP 用户粉丝信息表 |
|  ap_user_follow  | APP 用户关注信息表 |
| ap_user_realname | APP 实名认证信息表 |

登录需要用到的是 `ap_user` 表，表结构如下：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625224341998.png" alt="image-20240625224341998" style="zoom:40%;" />

⚠️ 注意事项：

- `tinyint` 类型：占 1 个字节，不指定 unsigned (非负数)，值范围 (-128,127)，指定了 unsigned，值范围 (0,255)

- `tinyint` 通常表示小范围的数值，或者表示 `true` 或 `false`，通常值为 0 表示 `false`,值为 1 表示 `true`；

项目中的持久层使用的 `mybatis-plus`，一般都使用 `mybais-plus` 逆向生成对应的实体类。

app_user 表对应的实体类如下：

```java
@Data
@TableName("ap_user")
public class ApUser implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 主键
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    /**
     * 密码、通信等加密盐
     */
    @TableField("salt")
    private String salt;

    /**
     * 用户名
     */
    @TableField("name")
    private String name;

    /**
     * 密码,md5加密
     */
    @TableField("password")
    private String password;

    /**
     * 手机号
     */
    @TableField("phone")
    private String phone;

    /**
     * 头像
     */
    @TableField("image")
    private String image;

    /**
     * 0 男
            1 女
            2 未知
     */
    @TableField("sex")
    private Boolean sex;

    /**
     * 0 未
            1 是
     */
    @TableField("is_certification")
    private Boolean certification;

    /**
     * 是否身份认证
     */
    @TableField("is_identity_authentication")
    private Boolean identityAuthentication;

    /**
     * 0正常
            1锁定
     */
    @TableField("status")
    private Boolean status;

    /**
     * 0 普通用户
            1 自媒体人
            2 大V
     */
    @TableField("flag")
    private Short flag;

    /**
     * 注册时间
     */
    @TableField("created_time")
    private Date createdTime;

}
```



### 手动加密

具体采用 md5 + 随机字符串 实现；

`md5` 是不可逆加密，`md5` 相同的密码每次加密都一样，不太安全。在 `md5` 的基础上手动加盐（salt）处理；



**注册 —> 生成盐：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625224441208.png" alt="image-20240625224441208" style="zoom:35%;" />

**登录 —> 使用盐来配合验证：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625224614946.png" alt="image-20240625224614946" style="zoom:35%;" />



**用户访问流程：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625224814630.png" alt="image-20240625224814630" style="zoom:35%;" />

- 用户输入了用户名和密码进行登录，校验成功后返回 `jwt`（基于当前用户的id生成）；
- 用户游客登录，生成 `jwt` 返回（基于默认值0生成）；



### 项目配置

`TJU-campus-service` 依赖信息说明

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625225912387.png" alt="image-20240625225912387" style="zoom:45%;" />

在 `TJU-campus-service` 下创建工程 `TJU-campus-user`：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625230838045.png" alt="image-20240625230838045" style="zoom:45%;" />

引导类：

```java
@SpringBootApplication
@EnableDiscoveryClient
@MapperScan("com.shawen.user.mapper")
public class UserApplication {

    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class,args);
    }
}
```

bootstrap.yml

```yaml
server:
  port: 51801
spring:
  application:
    name: leadnews-user
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
      config:
        server-addr: localhost:8848
        file-extension: yml
```

在 `nacos` 中创建配置文件：

```yaml
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/leadnews_user?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC&useSSL=false
    username: ****
    password: ****
# 设置Mapper接口所对应的XML文件位置，如果你在Mapper接口中有自定义方法，需要进行该配置
mybatis-plus:
  mapper-locations: classpath*:mapper/*.xml
  # 设置别名包扫描路径，通过该属性可以给包中的类注册别名
  type-aliases-package: com.shawen.model.user.pojos
```

`logback.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>

<configuration>
    <!--定义日志文件的存储地址,使用绝对路径-->
    <property name="LOG_HOME" value="logs"/>

    <!-- Console 输出设置 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            <charset>utf8</charset>
        </encoder>
    </appender>

    <!-- 按照每天生成日志文件 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--日志文件输出的文件名-->
            <fileNamePattern>${LOG_HOME}/leadnews.%d{yyyy-MM-dd}.log</fileNamePattern>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 异步输出 -->
    <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
        <!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 -->
        <discardingThreshold>0</discardingThreshold>
        <!-- 更改默认的队列的深度,该值会影响性能.默认值为256 -->
        <queueSize>512</queueSize>
        <!-- 添加附加的appender,最多只能添加一个 -->
        <appender-ref ref="FILE"/>
    </appender>


    <logger name="org.apache.ibatis.cache.decorators.LoggingCache" level="DEBUG" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>
    <logger name="org.springframework.boot" level="debug"/>
    <root level="info">
        <!--<appender-ref ref="ASYNC"/>-->
        <appender-ref ref="FILE"/>
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
```



### 接口文档

|          |         **说明**         |
| :------: | :----------------------: |
| 接口路径 | /api/v1/login/login_auth |
| 请求方式 |           POST           |
|   参数   |         LoginDto         |
| 响应结果 |      ResponseResult      |

**LoginDTO：**

```java
@Data
public class LoginDto {

    /**
     * 手机号
     */
    @ApiModelProperty(value = "手机号",required = true)
    private String phone;

    /**
     * 密码
     */
    @ApiModelProperty(value = "密码",required = true)
    private String password;
}
```

**ResponseResult：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626093406777.png" alt="image-20240626093406777" style="zoom:45%;" />

### 代码实现

①：控制层controller

```java
@RestController
@RequestMapping("/api/v1/login")
@Api(value = "app端用户登录",tags = "app端用户登录")
public class ApUserLoginController {

    @Autowired
    private ApUserService apUserService;

    @PostMapping("/login_auth")
    @ApiOperation("用户登录")
    public ResponseResult login(@RequestBody LoginDto dto){
        return apUserService.login(dto);
    }
}
```

②：持久层mapper

```java
@Mapper
public interface ApUserMapper extends BaseMapper<ApUser> {
}
```

③：业务层service

```java
public interface ApUserService extends IService<ApUser> {
    /**
     * app端登录功能
     * @param dto
     * @return
     */
    public ResponseResult login(LoginDto dto);
}
```

④：实现类

```java
@Service
@Transactional
@Slf4j
public class ApUserServiceImpl extends ServiceImpl<ApUserMapper, ApUser> implements ApUserService {
    /**
     * app端登录功能
     * @param dto
     * @return
     */
    @Override
    public ResponseResult login(LoginDto dto) {
        //1.正常登录 用户名和密码
        if(StringUtils.isNotBlank(dto.getPhone()) && StringUtils.isNotBlank(dto.getPassword())){
            //1.1 根据手机号查询用户信息
            ApUser dbUser = getOne(Wrappers.<ApUser>lambdaQuery()
                                   .eq(ApUser::getPhone, dto.getPhone()));
            if(dbUser == null){
                return ResponseResult.errorResult(AppHttpCodeEnum.DATA_NOT_EXIST,"用户信息不存在");
            }

            //1.2 比对密码
            String salt = dbUser.getSalt();
            String password = dto.getPassword();
            String pswd = DigestUtils.md5DigestAsHex((password + salt).getBytes());
            if(!pswd.equals(dbUser.getPassword())){
                return ResponseResult.errorResult(AppHttpCodeEnum.LOGIN_PASSWORD_ERROR);
            }

            //1.3 返回数据  jwt  user
            String token = AppJwtUtil.getToken(dbUser.getId().longValue());
            Map<String,Object> map = new HashMap<>();
            map.put("token",token);
            dbUser.setSalt("");
            dbUser.setPassword("");
            map.put("user",dbUser);

            return ResponseResult.okResult(map);
        }else {
            //2.游客登录
            Map<String,Object> map = new HashMap<>();
            map.put("token",AppJwtUtil.getToken(0L));
            return ResponseResult.okResult(map);
        }
    }
}
```



## 接口工具

### postman

Postman是一款功能强大的网页调试与发送网页 HTTP 请求的 Chrome 插件。postman 被500万开发者和超100,000家公司用于每月访问1.3亿个API。

官方网址：https://www.postman.com/

以下为登录请求的测试：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626101727300.png" alt="image-20240626101727300" style="zoom:70%;" />

### swagger

Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务(<https://swagger.io/>)。 它的主要作用是：

1. 使得前后端分离开发更加方便，有利于团队协作

2. 接口的文档在线自动生成，降低后端开发人员编写接口文档的负担

3. 功能测试 

	Spring 已经将 Swagger 纳入自身的标准，建立了 Spring-swagger 项目，现在叫 Springfox。通过在项目中引入 Springfox ，即可非常简单快捷的使用Swagger。



- **SpringBoot 集成 Swagger：**

引入依赖,在 TJU-campus-model 和 TJU-campus-common 模块中引入该依赖

```xml
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
</dependency>
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger-ui</artifactId>
</dependency>
```

只需要在 TJU-campus-common 中进行配置即可，因为其他微服务工程都直接或间接依赖即可。



- **在 TJU-campus-common 工程中添加一个配置类：**

新增：`package com.shawen.common.swagger.SwaggerConfiguration`

```java
@Configuration
@EnableSwagger2
public class SwaggerConfiguration {

   @Bean
   public Docket buildDocket() {
      return new Docket(DocumentationType.SWAGGER_2)
              .apiInfo(buildApiInfo())
              .select()
              // 要扫描的API(Controller)基础包
              .apis(RequestHandlerSelectors.basePackage("com.shawen"))
              .paths(PathSelectors.any())
              .build();
   }

   private ApiInfo buildApiInfo() {
      Contact contact = new Contact("何书文","","");
      return new ApiInfoBuilder()
              .title("TJU-campus-平台管理API文档")
              .description("TJU-campus后台api")
              .contact(contact)
              .version("1.0.0").build();
   }
}
```

在 `TJU-campus-common` 模块中的 `resources` 目录中新增以下目录和文件

文件：`resources/META-INF/Spring.factories`

```java
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.shawen.common.swagger.SwaggerConfiguration
```



- **Swagger 常用注解**

在 Java 类中添加 Swagger 的注解即可生成 Swagger 接口文档，常用 Swagger 注解如下：

@Api：修饰整个类，描述Controller的作用  

@ApiOperation：描述一个类的一个方法，或者说一个接口  

@ApiParam：单个参数的描述信息  

@ApiModel：用对象来接收参数  

@ApiModelProperty：用对象接收参数时，描述对象的一个字段  

@ApiResponse：HTTP响应其中1个描述  

@ApiResponses：HTTP响应整体描述  

@ApiIgnore：使用该注解忽略这个API  

@ApiError ：发生错误返回的信息  

@ApiImplicitParam：一个请求参数  

@ApiImplicitParams：多个请求参数的描述信息



 @ApiImplicitParam属性：

| 属性         | 取值   | 作用                                          |
| ------------ | ------ | --------------------------------------------- |
| paramType    |        | 查询参数类型                                  |
|              | path   | 以地址的形式提交数据                          |
|              | query  | 直接跟参数完成自动映射赋值                    |
|              | body   | 以流的形式提交 仅支持POST                     |
|              | header | 参数在request headers 里边提交                |
|              | form   | 以form表单的形式提交 仅支持POST               |
| dataType     |        | 参数的数据类型 只作为标志说明，并没有实际验证 |
|              | Long   |                                               |
|              | String |                                               |
| name         |        | 接收参数名                                    |
| value        |        | 接收参数的意义描述                            |
| required     |        | 参数是否必填                                  |
|              | true   | 必填                                          |
|              | false  | 非必填                                        |
| defaultValue |        | 默认值                                        |

我们在 `ApUserLoginController` 中添加 `Swagger` 注解，代码如下所示：

```java
@RestController
@RequestMapping("/api/v1/login")
@Api(value = "app端用户登录", tags = "ap_user", description = "app端用户登录API")
public class ApUserLoginController {

    @Autowired
    private ApUserService apUserService;

    @PostMapping("/login_auth")
    @ApiOperation("用户登录")
    public ResponseResult login(@RequestBody LoginDto dto){
        return apUserService.login(dto);
    }
}
```

LoginDto：

```java
@Data
public class LoginDto {

    /**
     * 手机号
     */
    @ApiModelProperty(value="手机号",required = true)
    private String phone;

    /**
     * 密码
     */
    @ApiModelProperty(value="密码",required = true)
    private String password;
}
```

启动 user 微服务，访问地址：http://localhost:51801/swagger-ui.html



### knife4j

- **简介：**

`knife4j` 是为 `Java MVC` 框架集成 `Swagger` 生成 Api 文档的增强解决方案，前身是 swagger-bootstrap-ui，取名 kni4j 是希望它能像一把匕首一样小巧，轻量，并且功能强悍!

gitee地址：https://gitee.com/xiaoym/knife4j

官方文档：https://doc.xiaominfo.com/

效果演示：http://knife4j.xiaominfo.com/doc.html

- **核心功能：**





## APP 端网关

### 网关概述

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626093703868.png" alt="image-20240626093703868" style="zoom:40%;" />

项目中网关服务的工程结构：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626093932168.png" alt="image-20240626093932168" style="zoom:45%;" />

###  jwt 校验

流程：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626094041322.png" alt="image-20240626094041322" style="zoom:40%;" />





## app前端项目集成

`nginx` 配置：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626094224696.png" alt="image-20240626094224696" style="zoom:40%;" />





































