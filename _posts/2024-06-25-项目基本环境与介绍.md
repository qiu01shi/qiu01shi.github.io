---
layout: post
title: 项目基本环境与介绍
date: 2024-06-25 21:44 +0800
categories: [TJU-news, 环境]
author: <author_id>
---

## 项目技术栈

基础层：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625215429943.png" alt="image-20240625215429943" style="zoom:35%;" />

服务层：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625215529989.png" alt="image-20240625215529989" style="zoom:35%;" />



## Nacos

Nacos 安装过程如下：

①：docker拉取镜像 

```shell
docker pull nacos/nacos-server:1.2.0
```

②：创建容器

```shell
docker run --env MODE=standalone --name nacos --restart=always  -d -p 8848:8848 nacos/nacos-server:1.2.0
```

- MODE=standalone 单机版

- --restart=always 开机启动

- -p 8848:8848  映射端口

- -d 创建一个守护式容器在后台运行

③：访问地址：http://localhost:8848/nacos 

## 初始工程搭建

**项目依赖环境：**

- JDK1.8

- Intellij Idea

- maven-3.6.1
- Git



**工程主题结构：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625220234725.png" alt="image-20240625220234725" style="zoom:35%;" />



**全局异常处理：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625220555896.png" alt="image-20240625220555896" style="zoom:35%;" />



## APP 登录

- 用户点击开始使用

	登录后的用户权限较大，可以查看，也可以操作（点赞，关注，评论）



- 用户点击不登录，先看看

	游客只有查看的权限

	<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625221306461.png" alt="image-20240625221306461" style="zoom:40%;" />

### 表结构分析

关于 app 端用户相关的内容较多，单独设置一个库 `leadnews_user` 用于存储

|    **表名称**    |      **说明**      |
| :--------------: | :----------------: |
|     ap_user      |   APP 用户信息表   |
|   ap_user_fan    | APP 用户粉丝信息表 |
|  ap_user_follow  | APP 用户关注信息表 |
| ap_user_realname | APP 实名认证信息表 |

登录需要用到的是 `ap_user` 表，表结构如下：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625224341998.png" alt="image-20240625224341998" style="zoom:40%;" />

⚠️ 注意事项：

- `tinyint` 类型：占 1 个字节，不指定 unsigned (非负数)，值范围 (-128,127)，指定了 unsigned，值范围 (0,255)

- `tinyint` 通常表示小范围的数值，或者表示 `true` 或 `false`，通常值为 0 表示 `false`,值为 1 表示 `true`；

项目中的持久层使用的 `mybatis-plus`，一般都使用 `mybais-plus` 逆向生成对应的实体类。

app_user 表对应的实体类如下：

```java
@Data
@TableName("ap_user")
public class ApUser implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 主键
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Integer id;

    /**
     * 密码、通信等加密盐
     */
    @TableField("salt")
    private String salt;

    /**
     * 用户名
     */
    @TableField("name")
    private String name;

    /**
     * 密码,md5加密
     */
    @TableField("password")
    private String password;

    /**
     * 手机号
     */
    @TableField("phone")
    private String phone;

    /**
     * 头像
     */
    @TableField("image")
    private String image;

    /**
     * 0 男
            1 女
            2 未知
     */
    @TableField("sex")
    private Boolean sex;

    /**
     * 0 未
            1 是
     */
    @TableField("is_certification")
    private Boolean certification;

    /**
     * 是否身份认证
     */
    @TableField("is_identity_authentication")
    private Boolean identityAuthentication;

    /**
     * 0正常
            1锁定
     */
    @TableField("status")
    private Boolean status;

    /**
     * 0 普通用户
            1 自媒体人
            2 大V
     */
    @TableField("flag")
    private Short flag;

    /**
     * 注册时间
     */
    @TableField("created_time")
    private Date createdTime;

}
```



### 用户操作流程

具体采用 md5 + 随机字符串 实现；

`md5` 是不可逆加密，`md5` 相同的密码每次加密都一样，不太安全。在 `md5` 的基础上手动加盐（salt）处理；



**注册 —> 生成盐：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625224441208.png" alt="image-20240625224441208" style="zoom:35%;" />

**登录 —> 使用盐来配合验证：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625224614946.png" alt="image-20240625224614946" style="zoom:35%;" />



**用户访问流程：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625224814630.png" alt="image-20240625224814630" style="zoom:35%;" />

- 用户输入了用户名和密码进行登录，校验成功后返回 `jwt`（基于当前用户的id生成）；
- 用户游客登录，生成 `jwt` 返回（基于默认值0生成）；



### 项目配置

`TJU-campus-service` 依赖信息说明

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625225912387.png" alt="image-20240625225912387" style="zoom:45%;" />

在 `TJU-campus-service` 下创建工程 `TJU-campus-user`：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240625230838045.png" alt="image-20240625230838045" style="zoom:45%;" />

引导类：

```java
@SpringBootApplication
@EnableDiscoveryClient
@MapperScan("com.shawen.user.mapper")
public class UserApplication {

    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class,args);
    }
}
```

bootstrap.yml

```yaml
server:
  port: 51801
spring:
  application:
    name: leadnews-user
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
      config:
        server-addr: localhost:8848
        file-extension: yml
```

在 `nacos` 中创建配置文件：

```yaml
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/leadnews_user?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC&useSSL=false
    username: ****
    password: ****
# 设置Mapper接口所对应的XML文件位置，如果你在Mapper接口中有自定义方法，需要进行该配置
mybatis-plus:
  mapper-locations: classpath*:mapper/*.xml
  # 设置别名包扫描路径，通过该属性可以给包中的类注册别名
  type-aliases-package: com.shawen.model.user.pojos
```

`logback.xml`

```xml
<?xml version="1.0" encoding="UTF-8"?>

<configuration>
    <!--定义日志文件的存储地址,使用绝对路径-->
    <property name="LOG_HOME" value="logs"/>

    <!-- Console 输出设置 -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <!--格式化输出：%d表示日期，%thread表示线程名，%-5level：级别从左显示5个字符宽度%msg：日志消息，%n是换行符-->
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
            <charset>utf8</charset>
        </encoder>
    </appender>

    <!-- 按照每天生成日志文件 -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <!--日志文件输出的文件名-->
            <fileNamePattern>${LOG_HOME}/leadnews.%d{yyyy-MM-dd}.log</fileNamePattern>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
    </appender>

    <!-- 异步输出 -->
    <appender name="ASYNC" class="ch.qos.logback.classic.AsyncAppender">
        <!-- 不丢失日志.默认的,如果队列的80%已满,则会丢弃TRACT、DEBUG、INFO级别的日志 -->
        <discardingThreshold>0</discardingThreshold>
        <!-- 更改默认的队列的深度,该值会影响性能.默认值为256 -->
        <queueSize>512</queueSize>
        <!-- 添加附加的appender,最多只能添加一个 -->
        <appender-ref ref="FILE"/>
    </appender>


    <logger name="org.apache.ibatis.cache.decorators.LoggingCache" level="DEBUG" additivity="false">
        <appender-ref ref="CONSOLE"/>
    </logger>
    <logger name="org.springframework.boot" level="debug"/>
    <root level="info">
        <!--<appender-ref ref="ASYNC"/>-->
        <appender-ref ref="FILE"/>
        <appender-ref ref="CONSOLE"/>
    </root>
</configuration>
```



### 接口描述

|          |         **说明**         |
| :------: | :----------------------: |
| 接口路径 | /api/v1/login/login_auth |
| 请求方式 |           POST           |
|   参数   |         LoginDto         |
| 响应结果 |      ResponseResult      |

**LoginDTO：**

```java
@Data
public class LoginDto {

    /**
     * 手机号
     */
    @ApiModelProperty(value = "手机号",required = true)
    private String phone;

    /**
     * 密码
     */
    @ApiModelProperty(value = "密码",required = true)
    private String password;
}
```

**ResponseResult：**

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626093406777.png" alt="image-20240626093406777" style="zoom:45%;" />

### 代码实现

①：控制层controller

```java
@RestController
@RequestMapping("/api/v1/login")
@Api(value = "app端用户登录",tags = "app端用户登录")
public class ApUserLoginController {

    @Autowired
    private ApUserService apUserService;

    @PostMapping("/login_auth")
    @ApiOperation("用户登录")
    public ResponseResult login(@RequestBody LoginDto dto){
        return apUserService.login(dto);
    }
}
```

②：持久层mapper

```java
@Mapper
public interface ApUserMapper extends BaseMapper<ApUser> {
}
```

③：业务层service

```java
public interface ApUserService extends IService<ApUser> {
    /**
     * app端登录功能
     * @param dto
     * @return
     */
    public ResponseResult login(LoginDto dto);
}
```

④：实现类

```java
@Service
@Transactional
@Slf4j
public class ApUserServiceImpl extends ServiceImpl<ApUserMapper, ApUser> implements ApUserService {
    /**
     * app端登录功能
     * @param dto
     * @return
     */
    @Override
    public ResponseResult login(LoginDto dto) {
        //1.正常登录 用户名和密码
        if(StringUtils.isNotBlank(dto.getPhone()) && StringUtils.isNotBlank(dto.getPassword())){
            //1.1 根据手机号查询用户信息
            ApUser dbUser = getOne(Wrappers.<ApUser>lambdaQuery()
                                   .eq(ApUser::getPhone, dto.getPhone()));
            if(dbUser == null){
                return ResponseResult.errorResult(AppHttpCodeEnum.DATA_NOT_EXIST,"用户信息不存在");
            }

            //1.2 比对密码
            String salt = dbUser.getSalt();
            String password = dto.getPassword();
            String pswd = DigestUtils.md5DigestAsHex((password + salt).getBytes());
            if(!pswd.equals(dbUser.getPassword())){
                return ResponseResult.errorResult(AppHttpCodeEnum.LOGIN_PASSWORD_ERROR);
            }

            //1.3 返回数据  jwt  user
            String token = AppJwtUtil.getToken(dbUser.getId().longValue());
            Map<String,Object> map = new HashMap<>();
            map.put("token",token);
            dbUser.setSalt("");
            dbUser.setPassword("");
            map.put("user",dbUser);

            return ResponseResult.okResult(map);
        }else {
            //2.游客登录
            Map<String,Object> map = new HashMap<>();
            map.put("token",AppJwtUtil.getToken(0L));
            return ResponseResult.okResult(map);
        }
    }
}
```



## 接口工具

### postman

Postman是一款功能强大的网页调试与发送网页 HTTP 请求的 Chrome 插件。postman 被500万开发者和超100,000家公司用于每月访问1.3亿个API。

官方网址：https://www.postman.com/

以下为登录请求的测试：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626101727300.png" alt="image-20240626101727300" style="zoom:70%;" />

### swagger

Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务(<https://swagger.io/>)。 它的主要作用是：

1. 使得前后端分离开发更加方便，有利于团队协作

2. 接口的文档在线自动生成，降低后端开发人员编写接口文档的负担

3. 功能测试 

	Spring 已经将 Swagger 纳入自身的标准，建立了 Spring-swagger 项目，现在叫 Springfox。通过在项目中引入 Springfox ，即可非常简单快捷的使用Swagger。



- **SpringBoot 集成 Swagger：**

引入依赖,在 TJU-campus-model 和 TJU-campus-common 模块中引入该依赖

```xml
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
</dependency>
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger-ui</artifactId>
</dependency>
```

只需要在 TJU-campus-common 中进行配置即可，因为其他微服务工程都直接或间接依赖即可。



- **在 TJU-campus-common 工程中添加一个配置类：**

新增：`package com.shawen.common.swagger.SwaggerConfiguration`

```java
@Configuration
@EnableSwagger2
public class SwaggerConfiguration {

   @Bean
   public Docket buildDocket() {
      return new Docket(DocumentationType.SWAGGER_2)
              .apiInfo(buildApiInfo())
              .select()
              // 要扫描的API(Controller)基础包
              .apis(RequestHandlerSelectors.basePackage("com.shawen"))
              .paths(PathSelectors.any())
              .build();
   }

   private ApiInfo buildApiInfo() {
      Contact contact = new Contact("何书文","","");
      return new ApiInfoBuilder()
              .title("TJU-campus-平台管理API文档")
              .description("TJU-campus后台api")
              .contact(contact)
              .version("1.0.0").build();
   }
}
```

在 `TJU-campus-common` 模块中的 `resources` 目录中新增以下目录和文件

文件：`resources/META-INF/Spring.factories`

```java
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.shawen.common.swagger.SwaggerConfiguration
```



- **Swagger 常用注解**

在 Java 类中添加 Swagger 的注解即可生成 Swagger 接口文档，常用 Swagger 注解如下：

@Api：修饰整个类，描述Controller的作用  

@ApiOperation：描述一个类的一个方法，或者说一个接口  

@ApiParam：单个参数的描述信息  

@ApiModel：用对象来接收参数  

@ApiModelProperty：用对象接收参数时，描述对象的一个字段  

@ApiResponse：HTTP响应其中1个描述  

@ApiResponses：HTTP响应整体描述  

@ApiIgnore：使用该注解忽略这个API  

@ApiError ：发生错误返回的信息  

@ApiImplicitParam：一个请求参数  

@ApiImplicitParams：多个请求参数的描述信息



 @ApiImplicitParam属性：

| 属性         | 取值   | 作用                                          |
| ------------ | ------ | --------------------------------------------- |
| paramType    |        | 查询参数类型                                  |
|              | path   | 以地址的形式提交数据                          |
|              | query  | 直接跟参数完成自动映射赋值                    |
|              | body   | 以流的形式提交 仅支持POST                     |
|              | header | 参数在request headers 里边提交                |
|              | form   | 以form表单的形式提交 仅支持POST               |
| dataType     |        | 参数的数据类型 只作为标志说明，并没有实际验证 |
|              | Long   |                                               |
|              | String |                                               |
| name         |        | 接收参数名                                    |
| value        |        | 接收参数的意义描述                            |
| required     |        | 参数是否必填                                  |
|              | true   | 必填                                          |
|              | false  | 非必填                                        |
| defaultValue |        | 默认值                                        |

我们在 `ApUserLoginController` 中添加 `Swagger` 注解，代码如下所示：

```java
@RestController
@RequestMapping("/api/v1/login")
@Api(value = "app端用户登录", tags = "ap_user", description = "app端用户登录API")
public class ApUserLoginController {

    @Autowired
    private ApUserService apUserService;

    @PostMapping("/login_auth")
    @ApiOperation("用户登录")
    public ResponseResult login(@RequestBody LoginDto dto){
        return apUserService.login(dto);
    }
}
```

LoginDto：

```java
@Data
public class LoginDto {

    /**
     * 手机号
     */
    @ApiModelProperty(value="手机号",required = true)
    private String phone;

    /**
     * 密码
     */
    @ApiModelProperty(value="密码",required = true)
    private String password;
}
```

启动 user 微服务，访问地址：http://localhost:51801/swagger-ui.html



### knife4j

- **简介：**

`knife4j` 是为 `Java MVC` 框架集成 `Swagger` 生成 Api 文档的增强解决方案，前身是 swagger-bootstrap-ui，取名 kni4j 是希望它能像一把匕首一样小巧，轻量，并且功能强悍!

gitee地址：https://gitee.com/xiaoym/knife4j

官方文档：https://doc.xiaominfo.com/

效果演示：http://knife4j.xiaominfo.com/doc.html



- **核心功能：**

该 `UI` 增强包主要包括两大核心功能：文档说明 和 在线调试

- 文档说明：根据 Swagger 的规范说明，详细列出接口文档的说明，包括接口地址、类型、请求示例、请求参数、响应示例、响应参数、响应码等信息，使用 swagger-bootstrap-ui 能根据该文档说明，对该接口的使用情况一目了然。
- 在线调试：提供在线接口联调的强大功能，自动解析当前接口参数,同时包含表单验证，调用参数可返回接口响应内容、headers、Curl 请求命令实例、响应时间、响应状态码等信息，帮助开发者在线调试，而不必通过其他测试工具测试接口是否正确,简介、强大。
- 个性化配置：通过个性化 ui 配置项，可自定义 UI 的相关显示信息。
- 离线文档：根据标准规范，生成的在线 markdown 离线文档，开发者可以进行拷贝生成 markdown 接口文档，通过其他第三方markdown 转换工具转换成 html 或 pdf，这样也可以放弃 swagger2markdown 组件。
- 接口排序：自 1.8.5 后，ui 支持了接口排序功能，例如一个注册功能主要包含了多个步骤,可以根据 swagger-bootstrap-ui 提供的接口排序规则实现接口的排序，step 化接口操作，方便其他开发者进行接口对接。



- **快速集成：**

在 TJU-campus-common 模块中的`pom.xml`文件中引入`knife4j`的依赖,如下：

```xml
<dependency>
     <groupId>com.github.xiaoymin</groupId>
     <artifactId>knife4j-spring-boot-starter</artifactId>
</dependency>
```

创建 Swagger 配置文件：

在 TJU-campus-common 模块中新建配置类

新建 Swagger 的配置文件`SwaggerConfiguration.java`文件,创建springfox提供的Docket分组对象,代码如下：

```java
@Configuration
@EnableSwagger2
@EnableKnife4j
@Import(BeanValidatorPluginsConfiguration.class)
public class Swagger2Configuration {

    @Bean(value = "defaultApi2")
    public Docket defaultApi2() {
        Docket docket=new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
                //分组名称
                .groupName("1.0")
                .select()
                //这里指定Controller扫描包路径
                .apis(RequestHandlerSelectors.basePackage("com.shawen"))
                .paths(PathSelectors.any())
                .build();
        return docket;
    }
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("TJU-campus-API文档")
                .description("TJU-campus-API文档")
                .version("1.0")
                .build();
    }
}
```

以上有两个注解需要特别说明，如下表：

| 注解              | 说明                                                         |
| ----------------- | ------------------------------------------------------------ |
| `@EnableSwagger2` | 该注解是Springfox-swagger框架提供的使用Swagger注解，该注解必须加 |
| `@EnableKnife4j`  | 该注解是`knife4j`提供的增强注解,Ui提供了例如动态参数、参数过滤、接口排序等增强功能,如果你想使用这些增强功能就必须加该注解，否则可以不用加 |

在 Spring.factories 中新增配置：

```java
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
  com.shawen.common.swagger.SwaggerConfiguration,\
  com.shawen.common.swagger.Swagger2Configuration
```

在浏览器输入地址：`http://host:port/doc.html` 即可访问



## APP 端网关

### 网关概述

基本流程如下：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626093703868.png" alt="image-20240626093703868" style="zoom:35%;" />

项目中网关服务的工程结构：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626093932168.png" alt="image-20240626093932168" style="zoom:35%;" />

### 项目配置

- 在 `TJU-campus-gateway` 导入以下依赖：

```xml
    <dependencies>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-gateway</artifactId>
        </dependency>
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
        </dependency>
        <dependency>
            <groupId>com.alibaba.cloud</groupId>
            <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt</artifactId>
        </dependency>
    </dependencies>
```

- 在 `TJU-campus-gateway  ` 下创建 `TJU-campus-app-gateway  `微服务：

引导类：

```java
@SpringBootApplication
@EnableDiscoveryClient //开启注册中心
public class AppGatewayApplication {

    public static void main(String[] args) {
        SpringApplication.run(AppGatewayApplication.class,args);
    }
}
```

`bootstrap.yml`

```yaml
server:
  port: 51601
spring:
  application:
    name: leadnews-app-gateway
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
      config:
        server-addr: localhost:8848
        file-extension: yml
```

在 `nacos` 的配置中心创建 dataid 为 leadnews-app-gateway 的 yml 配置

```yaml
spring:
  cloud:
    gateway:
      globalcors:
        add-to-simple-url-handler-mapping: true
        corsConfigurations:
          '[/**]':
            allowedHeaders: "*"
            allowedOrigins: "*"
            allowedMethods:
              - GET
              - POST
              - DELETE
              - PUT
              - OPTION
      routes:
        # 用户微服务
        - id: user
          uri: lb://leadnews-user
          predicates:
            - Path=/user/**
          filters:
            - StripPrefix= 1
```

环境搭建完成以后，启动项目网关和用户两个服务，使用 postman 进行测试

请求地址：http://localhost:51601/user/api/v1/login/login_auth  



### jwt 校验流程

使用全局过滤器实现 jwt 校验流程

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626094041322.png" alt="image-20240626094041322" style="zoom:35%;" />

思路分析：

1. 用户进入网关开始登陆，网关过滤器进行判断，如果是登录，则路由到后台管理微服务进行登录；
2. 用户登录成功，后台管理微服务签发 JWT TOKEN 信息返回给用户；
3. 用户再次进入网关开始访问，网关过滤器接收用户携带的 TOKEN；
4. 网关过滤器解析`TOKEN` ，判断是否有权限，如果有，则放行，如果没有则返回未认证错误；



### jwt 校验代码

第一：

​	在认证过滤器中需要用到 jwt 的解析，所以需要把工具类拷贝一份到网关微服务

第二：

​	在网关微服务中新建全局过滤器：

```java
package com.shawen.app.gateway.filter;

@Component
@Slf4j
public class AuthorizeFilter implements Ordered, GlobalFilter {
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        //1.获取request和response对象
        ServerHttpRequest request = exchange.getRequest();
        ServerHttpResponse response = exchange.getResponse();

        //2.判断是否是登录
        if(request.getURI().getPath().contains("/login")){
            //放行
            return chain.filter(exchange);
        }


        //3.获取token
        String token = request.getHeaders().getFirst("token");

        //4.判断token是否存在
        if(StringUtils.isBlank(token)){
            response.setStatusCode(HttpStatus.UNAUTHORIZED);
            return response.setComplete();
        }

        //5.判断token是否有效
        try {
            Claims claimsBody = AppJwtUtil.getClaimsBody(token);
            //是否是过期
            int result = AppJwtUtil.verifyToken(claimsBody);
            if(result == 1 || result  == 2){
                response.setStatusCode(HttpStatus.UNAUTHORIZED);
                return response.setComplete();
            }
        }catch (Exception e){
            e.printStackTrace();
            response.setStatusCode(HttpStatus.UNAUTHORIZED);
            return response.setComplete();
        }

        //6.放行
        return chain.filter(exchange);
    }

    /**
     * 优先级设置  值越小  优先级越高
     * @return
     */
    @Override
    public int getOrder() {
        return 0;
    }
}
```

测试：

启动 `user` 服务，继续访问其他微服务，会提示需要认证才能访问，这个时候需要在 `heads` 中设置设置`token`才能正常访问。



## app前端项目集成

`nginx` 配置：

<img src="../media/2024-06-25-%E9%A1%B9%E7%9B%AE%E5%9F%BA%E6%9C%AC%E7%8E%AF%E5%A2%83%E4%B8%8E%E4%BB%8B%E7%BB%8D/image-20240626094224696.png" alt="image-20240626094224696" style="zoom:40%;" />

通过 `nginx` 来进行配置，功能如下

- 通过 `nginx` 的反向代理功能访问后台的网关资源；
- 通过 `nginx` 的静态服务器功能访问前端静态页面；



**① 配置**`nginx`

配置 `nginx.conf` 文件

​		在`nginx`安装的`conf`目录下新建一个文件夹`leadnews.conf`,在当前文件夹中新建`TJU-campus-app.conf`文件

`TJU-campus-app.conf` 配置如下：

```nginx
upstream  TJU-campus-app-gateway{
    server localhost:51601;
}

server {
	listen 8801;
	location / {
		root ~/Documents/01_develop/myProjects/TJU-campus-leadnews/app-web;
		index index.html;
	}
	
	location ~/app/(.*) {
		proxy_pass http://TJU-campus-app-gateway/$1;
		proxy_set_header HOST $host;  # 不改变源请求头的值
		proxy_pass_request_body on;  #开启获取请求体
		proxy_pass_request_headers on;  #开启获取请求头
		proxy_set_header X-Real-IP $remote_addr;   # 记录真实发出请求的客户端IP
		proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  #记录代理信息
	}
}
```

nginx.conf   配置如下：

```nginx
worker_processes  1;

events {
    worker_connections  1024;
}
http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;
	# 引入自定义配置文件
	include leadnews.conf/*.conf;
}
```

**② 启动 nginx：**

在 nginx 安装包中使用命令提示符打开，输入命令 nginx 启动项目；

````shell
nginx -p `pwd`/ -c conf/nginx.conf
````

可查看进程，检查nginx是否启动	`ps -ef | grep nginx`

重新加载配置文件：`nginx -s reload`

③：打开前端项目进行测试  -- >  http://localhost:8801

​    用谷歌浏览器打开，调试移动端模式进行访问；
