---
layout: post
title: redis 分布式锁
date: 2024-07-02 10:33 +0800
categories: [Blogging,Redis]
author: <author_id>  
---

## 基本原理与实现方式对比

<img src="../media/2024-07-02-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/image-20240702103446133.png" alt="image-20240702103446133" style="zoom:40%;" />

**分布式锁：**满足分布式系统或集群模式下多进程可见并且互斥的锁。

分布式锁的核心思想就是让大家都使用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行，这就是分布式锁的核心思路

**分布式锁应该满足哪些条件？**

可见性：多个线程都能看到相同的结果，注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思；

互斥：互斥是分布式锁的最基本的条件，使得程序串行执行；

高可用：程序不易崩溃，时时刻刻都保证较高的可用性；

高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能；

安全性：安全也是程序中必不可少的一环；



<img src="../media/2024-07-02-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/image-20240702103826643.png" alt="image-20240702103826643" style="zoom:40%;" />



常见的分布式锁有三种

**Mysql：**mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见；

**Redis：**redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁；

**Zookeeper：**zookeeper也是企业级开发中较好的一个实现分布式锁的方案；

<img src="../media/2024-07-02-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/image-20240702104041572.png" alt="image-20240702104041572" style="zoom:50%;" />



## 实现思路

实现分布式锁时需要实现的两个基本方法：

* 获取锁：

	* 互斥：确保只能有一个线程获取锁
	* 非阻塞：尝试一次，成功返回`true`，失败返回`false`

	```shell
	# 添加锁，NX是互斥、EX是设置超时时间
	SET lock thread1 NX EX 10
	
	# 添加锁，利用setnx的互斥特性
	SETNX lock thread1
	
	# 添加锁过期时间，避免服务宕机引起的死锁
	EXPIRE lock 10
	```

	

* 释放锁：

	* 手动释放
	* 超时释放：获取锁时添加一个超时时间

```shell
# 释放锁，删除即可
DEL key
```



**核心思路：**

我们利用redis 的setNx 方法，当有多个线程进入时，我们就利用该方法，第一个线程进入时，redis 中就有这个key 了，返回了1，如果结果是1，则表示他抢到了锁，那么他去执行业务，然后再删除锁，退出锁逻辑，没有抢到锁的线程，等待一定时间后重试即可。

<img src="../media/2024-07-02-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/image-20240702104611917.png" alt="image-20240702104611917" style="zoom:50%;" />

**简单版本：**

```java
public interface ILock {

    /**
     * 尝试获取锁
     * @param timeoutSec 锁持有的超时时间，过期后自动释放
     * @return true代表获取锁成功; false代表获取锁失败
     */
    boolean tryLock(long timeoutSec);

    /**
     * 释放锁
     */
    void unlock();
}
```

- **加锁逻辑**

利用`setnx`方法进行加锁，同时增加过期时间，防止死锁，此方法可以保证加锁和增加过期时间具有原子性

```java
private static final String KEY_PREFIX="lock:"
@Override
public boolean tryLock(long timeoutSec) {
    // 获取线程标示
    String threadId = Thread.currentThread().getId()
    // 获取锁
    Boolean success = stringRedisTemplate.opsForValue()
            .setIfAbsent(KEY_PREFIX + name, threadId + "", timeoutSec, TimeUnit.SECONDS);
    return Boolean.TRUE.equals(success);
}
```

- **释放锁逻辑**

```java
public void unlock() {
    //通过del删除锁
    stringRedisTemplate.delete(KEY_PREFIX + name);
}
```



## 误删问题

### 产生原因

**流程：**

<img src="../media/2024-07-02-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/image-20240702105327191.png" alt="image-20240702105327191" style="zoom:50%;" />



**逻辑说明：**

持有锁的线程在锁的内部出现了阻塞，导致他的锁自动释放，这时其他线程，线程2来尝试获得锁，就拿到了这把锁，然后线程2在持有锁执行过程中，线程1反应过来，继续执行，而线程1执行过程中，走到了删除锁逻辑，此时就会把本应该属于线程2的锁进行删除，这就是误删别人锁的情况说明。



### 解决方案

在每个线程释放锁的时候，去判断一下当前这把锁是否属于自己，如果属于自己，则不进行锁的删除，假设还是上边的情况，线程1卡顿，锁自动释放，线程2进入到锁的内部执行逻辑，此时线程1反应过来，然后删除锁，但是线程1，一看当前这把锁不是属于自己，于是不进行删除锁逻辑，当线程2走到删除锁逻辑时，如果没有卡过自动释放锁的时间点，则判断当前这把锁是属于自己的，于是删除这把锁。



修改之前的分布式锁实现，在获取锁时存入线程标示（可以用UUID表示）在释放锁时先获取锁中的线程标示，判断是否与当前线程标示一致；

* 如果一致则释放锁
* 如果不一致则不释放锁

**核心逻辑：**在存入锁时，放入自己线程的标识，在删除锁时，判断当前这把锁的标识是不是自己存入的，如果是，则进行删除，如果不是，则不进行删除。

<img src="../media/2024-07-02-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/image-20240702110031054.png" alt="image-20240702110031054" style="zoom:50%;" />

**加锁：**

```java
private static final String ID_PREFIX = UUID.randomUUID().toString(true) + "-";
@Override
public boolean tryLock(long timeoutSec) {
   // 获取线程标示
   String threadId = ID_PREFIX + Thread.currentThread().getId();
   // 获取锁
   Boolean success = stringRedisTemplate.opsForValue()
                .setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);
   return Boolean.TRUE.equals(success);
}
```

**释放锁：**

```java
public void unlock() {
    // 获取线程标示
    String threadId = ID_PREFIX + Thread.currentThread().getId();
    // 获取锁中的标示
    String id = stringRedisTemplate.opsForValue().get(KEY_PREFIX + name);
    // 判断标示是否一致
    if(threadId.equals(id)) {
        // 释放锁
        stringRedisTemplate.delete(KEY_PREFIX + name);
    }
}
```



## 原子性问题

线程1现在持有锁之后，在执行业务逻辑过程中，他正准备删除锁，而且已经走到了条件判断的过程中，比如他已经拿到了当前这把锁确实是属于他自己的，正准备删除锁，但是此时他的锁到期了，那么此时线程2进来，但是线程1他会接着往后执行，当他卡顿结束后，他直接就会执行删除锁那行代码，相当于条件判断并没有起到作用，这就是删锁时的原子性问题，之所以有这个问题，是因为线程1的拿锁，比锁，删锁，实际上并不是原子性的，我们要防止刚才的情况发生，

<img src="../media/2024-07-02-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/image-20240702110447889.png" alt="image-20240702110447889" style="zoom:50%;" />



## Lua脚本解决多条命令原子性问题

Redis提供了Lua脚本功能，在一个脚本中编写多条Redis命令，确保多条命令执行时的原子性。Lua是一种编程语言，它的基本语法可以参考网站：https://www.runoob.com/lua/lua-tutorial.html，这里重点介绍Redis提供的调用函数，我们可以使用lua去操作redis，又能保证他的原子性，这样就可以实现拿锁比锁删锁是一个原子性动作了。

这里重点介绍Redis提供的调用函数，语法如下：

```lua
redis.call('命令名称', 'key', '其它参数', ...)
```

例如，我们要执行`set name jack`，则脚本是这样：

```lua
# 执行 set name jack
redis.call('set', 'name', 'jack')
```

例如，我们要先执行`set name Rose`，再执行`get name`，则脚本如下：

```lua
# 先执行 set name jack
redis.call('set', 'name', 'Rose')
# 再执行 get name
local name = redis.call('get', 'name')
# 返回
return name
```

写好脚本以后，需要用`Redis`命令来调用脚本，调用脚本的常见命令如下：

<img src="../media/2024-07-02-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/image-20240702110748320.png" alt="image-20240702110748320" style="zoom:50%;" />

例如，我们要执行 `redis.call('set', 'name', 'jack')` 这个脚本，语法如下：

<img src="../media/2024-07-02-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/image-20240702110842194.png" alt="image-20240702110842194" style="zoom:50%;" />

如果脚本中的`key`、`value`不想写死，可以作为参数传递。`key` 类型参数会放入 `KEYS` 数组，其它参数会放入 `ARGV` 数组，在脚本中可以从 `KEYS` 和 `ARGV` 数组获取这些参数：

<img src="../media/2024-07-02-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/1653392438917.png" alt="1653392438917" style="zoom:60%;" />



接下来我们来回一下我们释放锁的逻辑：

释放锁的业务流程是这样的

​	1、获取锁中的线程标示

​	2、判断是否与指定的标示（当前线程标示）一致

​	3、如果一致则释放锁（删除）

​	4、如果不一致则什么都不做

最终我们操作`redis`的拿锁比锁删锁的`lua`脚本就会变成这样

```lua
-- 这里的 KEYS[1] 就是锁的key，这里的ARGV[1] 就是当前线程标示
-- 获取锁中的标示，判断是否与当前线程标示一致
if (redis.call('GET', KEYS[1]) == ARGV[1]) then
  -- 一致，则删除锁
  return redis.call('DEL', KEYS[1])
end
-- 不一致，则直接返回
return 0
```

##  Lua 脚本改造分布式锁

`RedisTemplate`调用`Lua`脚本的 `API` 如下：

<img src="../media/2024-07-02-redis-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/image-20240702111526727.png" alt="image-20240702111526727" style="zoom:50%;" />

```java
private static final DefaultRedisScript<Long> UNLOCK_SCRIPT;
    static {
        UNLOCK_SCRIPT = new DefaultRedisScript<>();
        UNLOCK_SCRIPT.setLocation(new ClassPathResource("unlock.lua"));
        UNLOCK_SCRIPT.setResultType(Long.class);
    }

public void unlock() {
    // 调用lua脚本
    stringRedisTemplate.execute(
            UNLOCK_SCRIPT,
            Collections.singletonList(KEY_PREFIX + name),
            ID_PREFIX + Thread.currentThread().getId());
}
// 经过以上代码改造后，我们就能够实现 拿锁比锁删锁的原子性动作了~
```
