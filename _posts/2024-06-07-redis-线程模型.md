---
layout: post
title: Redis 网络模型
author: 求是君
categories: [Redis,  网络模型]
date: 2024-06-07 09:48 +0800
---

## 用户空间和内核态空间

任何 `Linux` 发行版，其系统内核都是 `Linux` 。我们的应用都需要通过 `Linux` 内核与硬件交互。

<img src="../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607215524235.png" alt="image-20240607215524235" style="zoom:50%;" />

为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的：

- 进程的寻址空间会划分为两部分：**内核空间**、**用户空间**；

- 用户空间只能执行受限的命令（`Ring3`），而且不能直接调用系统资源，必须通过内核提供的接口来访问；
- 内核空间可以执行特权命令（`Ring0`），调用一切系统资源；

比如一个 32 位的操作系统，他的带宽就是 32，他的虚拟地址就是 2 的 32 次方，也就是说他寻址的范围就是 0 ~ 2 的 32 次方， 这片寻址空间对应的就是 2 的 32 个字节，就是 4GB，这个 4GB，会有 3 GB 分给用户空间，1GB 给内核系统；

<img src="../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607214058068.png" alt="image-20240607214058068" style="zoom:50%;" />

Linux系统为了提高 IO 效率，会在用户空间和内核空间都加入缓冲区：

- 写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备；

- 读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区；

针对这个操作：我们的用户在写读数据时，会去向内核态申请，想要读取内核的数据，而内核数据要去等待驱动程序从硬件上读取数据，当从磁盘上加载到数据之后，内核会将数据写入到内核的缓冲区中，然后再将数据拷贝到用户态的 `buffer` 中，然后再返回给应用程序，整体而言，速度慢，就是这个原因，为了加速，我们希望 `read` 也好，还是 `wait for data` 也最好都不要等待，或者时间尽量的短。

<img src="../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607212500821.png" alt="image-20240607212500821" style="zoom:55%;" />

## 5种 IO 模型

在《UNIX网络编程》一书中，总结归纳了 5 种 IO 模型：

- 阻塞IO（Blocking IO）
- 非阻塞IO（Nonblocking IO）
- IO多路复用（IO Multiplexing）
- 信号驱动IO（Signal Driven IO）
- 异步IO（Asynchronous IO）

<img src="../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607220602688.png" alt="image-20240607220602688" style="zoom:50%;" />

应用程序想要去读取数据，他是无法直接去读取磁盘数据的，他需要先到内核里边去等待内核操作硬件拿到数据，这个过程就是1，是需要等待的，等到内核从磁盘上把数据加载出来之后，再把这个数据写给用户的缓存区，这个过程是 2，如果是阻塞 IO，那么整个过程中，用户从发起读请求开始，一直到读取到数据，都是一个阻塞状态。

### 阻塞 IO

**阻塞 `IO`** 就是**两个阶段都必须阻塞等待：**

<img src="../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607221146281.png" alt="image-20240607221146281" style="zoom:50%;" />

**阶段一：**

- 用户进程尝试读取数据（比如网卡数据）
- 此时数据尚未到达，内核需要等待数据
- 此时用户进程也处于阻塞状态

**阶段二：**

* 数据到达并拷贝到内核缓冲区，代表已就绪
* 将内核数据拷贝到用户缓冲区
* 拷贝过程中，用户进程依然阻塞等待
* 拷贝完成，用户进程解除阻塞，处理数据

可以看到，阻塞 IO 模型中，用户进程在两个阶段都是阻塞状态。

### 非阻塞 IO

顾名思义，**非阻塞 `IO`** 的 `recvfrom` 操作会立即返回结果而不是阻塞用户进程。

<img src="../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607221904747.png" alt="image-20240607221904747" style="zoom:50%;" />

**阶段一：**

* 用户进程尝试读取数据（比如网卡数据）
* 此时数据尚未到达，内核需要等待数据
* 返回异常给用户进程
* 用户进程拿到 `error` 后，再次尝试读取
* 循环往复，直到数据就绪

**阶段二：**

* 将内核数据拷贝到用户缓冲区
* 拷贝过程中，用户进程依然阻塞等待
* 拷贝完成，用户进程解除阻塞，处理数据
* 可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致 `CPU` 空转，`CPU` 使用率暴增。

### IO 多路复用

无论是阻塞IO还是非阻塞IO，用户应用在一阶段都需要调用recvfrom来获取数据，差别在于无数据时的处理方案：

- 如果调用 `recvfrom` 时，恰好没有数据，**阻塞 IO 会使 CPU 阻塞，非阻塞 IO 使 CPU 空转**，都不能充分发挥 CPU 的作用；
- 如果调用 `recvfrom` 时，恰好有数据，则用户进程可以直接进入第二阶段，读取并处理数据。

而在单线程情况下，**只能依次处理 IO 事件**，如果正在处理的 IO 事件恰好未就绪（数据不可读或不可写），线程就会被阻塞，所有IO 事件都必须等待，性能自然会很差。

就比如服务员给顾客点餐，**分两步**：

1. 顾客思考要吃什么（等待数据就绪）

2. 顾客想好了，开始点餐（读取数据）

<img src="../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607223204938.png" alt="image-20240607223204938" style="zoom:50%;" />

要提高效率有几种办法？

- 方案一：增加更多服务员（多线程）
- 方案二：不排队，谁想好了吃什么（数据就绪了），服务员就给谁点餐（用户应用就去读取数据）

那么问题来了：用户进程如何知道内核中数据是否就绪呢？



**文件描述符**（File Descriptor）：简称 `FD`，**是一个从 0 开始的无符号整数**，用来关联 `Linux` 中的一个文件。在 `Linux` 中，一切皆文件，例如常规文件、视频、硬件设备等，当然也包括网络套接字（`Socket`）。

**IO多路复用**：是利用 **单个线程来同时监听多个 `FD`**，并在某个 `FD` 可读、可写时得到通知，从而避免无效的等待，充分利用 `CPU`资源。

<img src="../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607223806039.png" alt="image-20240607223806039" style="zoom:50%;" />

**阶段一：**

* 用户进程调用 `select`，指定要监听的 `FD` 集合
* 内核监听 `FD` 对应的多个 `socket`
* 任意一个或多个 `socket` 数据就绪则返回 `readable`
* 此过程中用户进程阻塞

**阶段二：**

* 用户进程找到就绪的 `socket`
* 依次调用`recvfrom`读取数据
* 内核将数据拷贝到用户空间
* 用户进程处理数据

当用户去读取数据的时候，不再去直接调用 `recvfrom` 了，而是调用 `select` 的函数，select函数会将需要监听的数据交给内核，由内核去检查这些数据是否就绪了，如果说这个数据就绪了，就会通知应用程序数据就绪，然后来读取数据，再从内核中把数据拷贝给用户态，完成数据处理，如果N多个FD一个都没处理完，此时就进行等待。

<img src="../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607224212738.png" alt="image-20240607224212738" style="zoom:50%;" />

**`IO` 多路复用** 是利用单个线程来同时监听多个FD，并在某个FD可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。不过监听FD的方式、通知的方式又有多种实现，常见的有：

- select
- poll
- epoll

**差异：**

- `select` 和 `poll` 只会通知用户进程有FD就绪，但不确定具体是哪个 `FD`，需要用户进程 **逐个遍历 `FD` 来确认**；

- `epoll` 则会在通知用户进程 `FD` 就绪的同时，把已就绪的 `FD` 写入用户空间；



### IO 多路复用-Select

`select` 是 `Linux` 最早使用的 `I/O` 多路复用技术：



```c
// 定义类型别名 __fd_mask，本质是 long int
typedef long int __fd_mask;

/* fd_set 记录要监听的fd集合，及其对应状态 */
typedef struct {
  // fds_bits是long类型数组，长度为 1024/32 = 32
  // 共1024个bit位，每个bit位代表一个fd，0代表未就绪，1代表就绪
  __fd_mask fds_bits[__FD_SETSIZE / __NFDBITS];
  // ...
} fd_set;

// select函数，用于监听fd_set，也就是多个fd的集合
int select(
  int nfds, // 要监视的fd_set的最大fd + 1
	fd_set *readfds, // 要监听读事件的fd集合
	fd_set *writefds,// 要监听写事件的fd集合
	fd_set *exceptfds, // // 要监听异常事件的fd集合
	// 超时时间，null-用不超时；0-不阻塞等待；大于0-固定等待时间
	struct timeval *timeout
);
```



简单说，就是我们把需要处理的数据封装成 FD，然后在用户态时创建一个 fd 的集合（这个集合的大小是要监听的那个FD的最大值+1，但是大小整体是有限制的 ），**这个集合的长度大小是有限制的**，同时在这个集合中，标明出来我们要控制哪些数据，

比如要监听的数据，是 `1, 2, 5` 三个数据，此时会执行 `select` 函数，然后将整个 `fd` 发给内核态，内核态会去遍历用户态传递过来的数据，如果发现这里边都数据都没有就绪，就休眠，直到有数据准备好时，就会被唤醒，唤醒之后，再次遍历一遍，看看谁准备好了，然后再处理准备好的数据，最后再将这个 `FD` 集合写回到用户态中去，此时用户态就知道了，奥，有人准备好了，但是对于用户态而言，并不知道谁处理好了，所以用户态也需要去进行遍历，然后找到对应准备好数据的节点，再去发起读请求，我们会发现，这种模式下他虽然比阻塞 IO 和非阻塞 IO 好，但是依然有些麻烦的事情， 比如说 **频繁的传递fd集合，频繁的去遍历FD等问题。**

**用户空间拷贝到内核空间：**

<img src="../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607235512336.png" alt="image-20240607235512336" style="zoom:50%;" />

**内核空间拷贝到用户空间：**

<img src="../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607234714989.png" alt="image-20240607234714989" style="zoom:50%;" />

**select 模式存在的问题：**

- 需要将整个 `fd_set` 从用户空间拷贝到内核空间，`select` 结束还要再次拷贝回用户空间；
- `select` 无法得知具体是哪个 `fd` 就绪；
- 需要遍历整个 `fd_setfd_set` 监听的 `fd` 数量不能超过 `1024`。





