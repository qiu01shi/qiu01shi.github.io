---
layout: post
title: Redis 网络模型
author: 求是君
categories: [Redis,  网络模型]
date: 2024-06-07 09:48 +0800
---

## 用户空间和内核态空间

任何 `Linux` 发行版，其系统内核都是 `Linux` 。我们的应用都需要通过 `Linux` 内核与硬件交互。

![image-20240607215524235](../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607215524235.png)

为了避免用户应用导致冲突甚至内核崩溃，用户应用与内核是分离的：

- 进程的寻址空间会划分为两部分：**内核空间**、**用户空间**；

- 用户空间只能执行受限的命令（`Ring3`），而且不能直接调用系统资源，必须通过内核提供的接口来访问；
- 内核空间可以执行特权命令（`Ring0`），调用一切系统资源；

比如一个 32 位的操作系统，他的带宽就是 32，他的虚拟地址就是 2 的 32 次方，也就是说他寻址的范围就是 0 ~ 2 的 32 次方， 这片寻址空间对应的就是 2 的 32 个字节，就是 4GB，这个 4GB，会有 3 GB 分给用户空间，1GB 给内核系统；

<img src="../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607214058068.png" alt="image-20240607214058068" style="zoom:50%;" />

Linux系统为了提高 IO 效率，会在用户空间和内核空间都加入缓冲区：

- 写数据时，要把用户缓冲数据拷贝到内核缓冲区，然后写入设备；

- 读数据时，要从设备读取数据到内核缓冲区，然后拷贝到用户缓冲区；

针对这个操作：我们的用户在写读数据时，会去向内核态申请，想要读取内核的数据，而内核数据要去等待驱动程序从硬件上读取数据，当从磁盘上加载到数据之后，内核会将数据写入到内核的缓冲区中，然后再将数据拷贝到用户态的 `buffer` 中，然后再返回给应用程序，整体而言，速度慢，就是这个原因，为了加速，我们希望 `read` 也好，还是 `wait for data` 也最好都不要等待，或者时间尽量的短。

<img src="../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607212500821.png" alt="image-20240607212500821" style="zoom:55%;" />

## 5种 IO 模型

在《UNIX网络编程》一书中，总结归纳了 5 种 IO 模型：

- 阻塞IO（Blocking IO）
- 非阻塞IO（Nonblocking IO）
- IO多路复用（IO Multiplexing）
- 信号驱动IO（Signal Driven IO）
- 异步IO（Asynchronous IO）

<img src="../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607220602688.png" alt="image-20240607220602688" style="zoom:50%;" />

应用程序想要去读取数据，他是无法直接去读取磁盘数据的，他需要先到内核里边去等待内核操作硬件拿到数据，这个过程就是1，是需要等待的，等到内核从磁盘上把数据加载出来之后，再把这个数据写给用户的缓存区，这个过程是 2，如果是阻塞 IO，那么整个过程中，用户从发起读请求开始，一直到读取到数据，都是一个阻塞状态。

### 阻塞 IO

**阻塞 `IO`** 就是**两个阶段都必须阻塞等待：**

<img src="../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607221146281.png" alt="image-20240607221146281" style="zoom:50%;" />

**阶段一：**

- 用户进程尝试读取数据（比如网卡数据）
- 此时数据尚未到达，内核需要等待数据
- 此时用户进程也处于阻塞状态

**阶段二：**

* 数据到达并拷贝到内核缓冲区，代表已就绪
* 将内核数据拷贝到用户缓冲区
* 拷贝过程中，用户进程依然阻塞等待
* 拷贝完成，用户进程解除阻塞，处理数据

可以看到，阻塞 IO 模型中，用户进程在两个阶段都是阻塞状态。

### 非阻塞 IO

顾名思义，**非阻塞 `IO`** 的 `recvfrom` 操作会立即返回结果而不是阻塞用户进程。

<img src="../media/2024-06-07-redis-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/image-20240607221904747.png" alt="image-20240607221904747" style="zoom:50%;" />

**阶段一：**

* 用户进程尝试读取数据（比如网卡数据）
* 此时数据尚未到达，内核需要等待数据
* 返回异常给用户进程
* 用户进程拿到 `error` 后，再次尝试读取
* 循环往复，直到数据就绪

**阶段二：**

* 将内核数据拷贝到用户缓冲区
* 拷贝过程中，用户进程依然阻塞等待
* 拷贝完成，用户进程解除阻塞，处理数据
* 可以看到，非阻塞IO模型中，用户进程在第一个阶段是非阻塞，第二个阶段是阻塞状态。虽然是非阻塞，但性能并没有得到提高。而且忙等机制会导致 `CPU` 空转，`CPU` 使用率暴增。

### IO 多路复用
