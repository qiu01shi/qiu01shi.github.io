---
layout: post
title: 字节码文件详解
date: 2024-07-08 20:08 +0800
categories: [Java, JVM]
author: <author_id>  
---

## JVM 的组成

Java 虚拟机主要分为以下几个组成部分：



<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708201451471.png" alt="image-20240708201451471" style="zoom:35%;" />



- 类加载子系统：核心组件类加载器，负责将字节码文件中的内容加载到内存中。
- 运行时数据区：JVM管理的内存，创建出来的对象、类的信息等等内容都会放在这块区域中。
- 执行引擎：包含了即时编译器、解释器、垃圾回收器，执行引擎使用解释器将字节码指令解释成机器码，使用即时编译器优化性能，使用垃圾回收器回收不再使用的对象。

- 本地接口：调用本地使用C/C++编译好的方法，本地方法在Java中声明时，都会带上 native 关键字，如下图所示。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708201654978.png" alt="image-20240708201654978" style="zoom:45%;" />



## 字节码文件的组成

使用 jclasslib 工具查看字节码文件；Github地址： https://github.com/ingokegel/jclasslib

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708202140821.png" alt="image-20240708202140821" style="zoom:45%;" />

字节码文件总共可以分为以下几个部分：

- **基础信息**：魔数、字节码文件对应的Java版本号、访问标识(public final等等)、父类和接口信息；
- **常量池**： 保存了字符串常量、类或接口名、字段名，主要在字节码指令中使用；
- **字段：** 当前类或接口声明的字段信息；
- **方法：** 当前类或接口声明的方法信息，核心内容为方法的字节码指令；
- **属性：** 类的属性，比如源码的文件名、内部类的列表等；



### 基本信息

包含了 jclasslib 中能看到的两块内容：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708202711822.png" alt="image-20240708202711822" style="zoom:65%;" />

**①  Magic 魔数**

每个 Java 字节码文件的前四个字节是固定的，用16进制表示就是 0xcafebabe。

- 文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改不影响文件的内容。
- 软件会使用文件的头几个字节（文件头）去校验文件的类型，如果软件不支持该种类型就会出错。
- Java字节码文件中，将文件头称为 magic 魔数。



比如常见的文件格式校验方式如下：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708203419522.png" alt="image-20240708203419522" style="zoom:40%;" />

**②  主副版本号**

- 主副版本号指的是编译字节码文件的JDK版本号，主版本号用来标识大版本号，JDK1.0-1.1 使用了 45.0-45.3，JDK 1.2 是 46 之后每升级一个大版本就加 1；副版本号是当主版本号相同时作为区分不同版本的标识，一般只需要关心主版本号。

- **版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容。**

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708204046906.png" alt="image-20240708204046906" style="zoom:50%;" />

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708204111832.png" alt="image-20240708204111832" style="zoom:50%;" />

对于以下错误，有两种解决方案：

1,  升级JDK版本，将图中使用的JDK6升级至JDK8即可正常运行，容易引发其他的兼容性问题，并且需要大量的测试。

2,  将第三方依赖的版本号降低或者更换依赖，以满足JDK版本的要求。<font color='red'>建议使用这种方案</font>

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708204229535.png" alt="image-20240708204229535" style="zoom:30%;" />



**③  其他基础信息**

其他基础信息包括访问标识、类和接口索引，如下：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/output.png" alt="output" style="zoom:60%;" />



### 常量池

字节码文件中常量池的作用：避免相同的内容重复定义，节省空间。

- 常量池中的数据都有一个编号，编号从 1 开始。在字段或者字节码指令中通过编号可以快速的找到对应的数据。

- 字节码指令中通过编号引用到常量池的过程称之为 **符号引用**。



### 字段

字段中存放的是当前类或接口声明的字段信息。

如下图中，定义了两个字段 `a1` 和 `a2`，这两个字段就会出现在字段这部分内容中。同时还包含字段的名字、描述符（字段的类型）、访问标识（public/private  static  final等）。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/1108c3bf-f777-47c3-a766-c693984215a5.png" alt="1108c3bf-f777-47c3-a766-c693984215a5" style="zoom:70%;" />

### 方法

字节码中的方法区域是存放 **字节码指令** 的核心位置，字节码指令的内容存放在方法的 Code 属性中。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708210659893.png" alt="image-20240708210659893" style="zoom:50%;" />

```java
int i = 0;
int j = i + 1;
```

上述 java 代码翻译成字节码指令之后如下：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image%20(1).png" alt="image (1)" style="zoom:45%;" />

要理解这段字节码指令是如何执行的，我们需要先理解两块内存区域：操作数栈和局部变量表。

- **操作数栈** 是用来存放临时数据的内容，是一个栈式的结构，先进后出。

- **局部变量表** 是存放方法中的局部变量，包含方法的参数、方法中定义的局部变量，在编译期就已经可以确定方法有多少个局部变量。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708211413930.png" alt="image-20240708211413930" style="zoom:35%;" />

1、iconst_0：将常量0放入操作数栈。此时栈上只有0。

2、istore_1：会从操作数栈中，将栈顶的元素弹出来，此时0会被弹出，放入局部变量表的1号位置。局部变量表中的1号位置，在编译时就已经确定是局部变量i使用的位置。完成了对局部变量i的赋值操作。

3、iload_1：将局部变量表1号位置的数据放入操作数栈中，此时栈中会放入0。

4、iconst_1：会将常量1放入操作数栈中。

5、iadd：会将操作数栈顶部的两个数据相加，现在操作数栈上有两个数0和1，相加之后结果为1放入操作数栈中，此时栈上只有一个数也就是相加的结果1。

6、istore_2：从操作数栈中将1弹出，并放入局部变量表的2号位置，2号位置是j在使用。完成了对局部变量j的赋值操作。

7、return：语句执行，方法结束并返回。



### 属性

属性主要指的是类的属性，比如源码的文件名、内部类的列表等。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image%20(2).png" alt="image (2)" style="zoom:65%;" />
