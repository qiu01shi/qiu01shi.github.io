---
layout: post
title: 字节码文件详解
date: 2024-07-08 20:08 +0800
categories: [基础知识, JVM]
author: <author_id>  
---

## JVM 的组成

Java 虚拟机主要分为以下几个组成部分：



<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708201451471.png" alt="image-20240708201451471" style="zoom:35%;" />



- 类加载子系统：核心组件类加载器，负责将字节码文件中的内容加载到内存中。
- 运行时数据区：JVM管理的内存，创建出来的对象、类的信息等等内容都会放在这块区域中。
- 执行引擎：包含了即时编译器、解释器、垃圾回收器，执行引擎使用解释器将字节码指令解释成机器码，使用即时编译器优化性能，使用垃圾回收器回收不再使用的对象。

- 本地接口：调用本地使用C/C++编译好的方法，本地方法在Java中声明时，都会带上 native 关键字，如下图所示。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708201654978.png" alt="image-20240708201654978" style="zoom:45%;" />



## 字节码文件的组成

使用 jclasslib 工具查看字节码文件；Github地址： https://github.com/ingokegel/jclasslib

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708202140821.png" alt="image-20240708202140821" style="zoom:45%;" />

字节码文件总共可以分为以下几个部分：

- **基础信息**：魔数、字节码文件对应的Java版本号、访问标识(public final等等)、父类和接口信息；
- **常量池**： 保存了字符串常量、类或接口名、字段名，主要在字节码指令中使用；
- **字段：** 当前类或接口声明的字段信息；
- **方法：** 当前类或接口声明的方法信息，核心内容为方法的字节码指令；
- **属性：** 类的属性，比如源码的文件名、内部类的列表等；



### 基本信息

包含了 jclasslib 中能看到的两块内容：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708202711822.png" alt="image-20240708202711822" style="zoom:65%;" />

**①  Magic 魔数**

每个 Java 字节码文件的前四个字节是固定的，用16进制表示就是 0xcafebabe。

- 文件是无法通过文件扩展名来确定文件类型的，文件扩展名可以随意修改不影响文件的内容。
- 软件会使用文件的头几个字节（文件头）去校验文件的类型，如果软件不支持该种类型就会出错。
- Java字节码文件中，将文件头称为 magic 魔数。



比如常见的文件格式校验方式如下：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708203419522.png" alt="image-20240708203419522" style="zoom:40%;" />

**②  主副版本号**

- 主副版本号指的是编译字节码文件的JDK版本号，主版本号用来标识大版本号，JDK1.0-1.1 使用了 45.0-45.3，JDK 1.2 是 46 之后每升级一个大版本就加 1；副版本号是当主版本号相同时作为区分不同版本的标识，一般只需要关心主版本号。

- **版本号的作用主要是判断当前字节码的版本和运行时的JDK是否兼容。**

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708204046906.png" alt="image-20240708204046906" style="zoom:50%;" />

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708204111832.png" alt="image-20240708204111832" style="zoom:50%;" />

对于以下错误，有两种解决方案：

1,  升级JDK版本，将图中使用的JDK6升级至JDK8即可正常运行，容易引发其他的兼容性问题，并且需要大量的测试。

2,  将第三方依赖的版本号降低或者更换依赖，以满足JDK版本的要求。<font color='red'>建议使用这种方案</font>

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708204229535.png" alt="image-20240708204229535" style="zoom:30%;" />



**③  其他基础信息**

其他基础信息包括访问标识、类和接口索引，如下：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/output.png" alt="output" style="zoom:50%;" />



### 常量池

字节码文件中常量池的作用：避免相同的内容重复定义，节省空间。

- 常量池中的数据都有一个编号，编号从 1 开始。在字段或者字节码指令中通过编号可以快速的找到对应的数据。

- 字节码指令中通过编号引用到常量池的过程称之为 **符号引用**。



### 字段

字段中存放的是当前类或接口声明的字段信息。

如下图中，定义了两个字段 `a1` 和 `a2`，这两个字段就会出现在字段这部分内容中。同时还包含字段的名字、描述符（字段的类型）、访问标识（public/private  static  final等）。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/1108c3bf-f777-47c3-a766-c693984215a5.png" alt="1108c3bf-f777-47c3-a766-c693984215a5" style="zoom:70%;" />

### 方法

字节码中的方法区域是存放 **字节码指令** 的核心位置，字节码指令的内容存放在方法的 Code 属性中。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708210659893.png" alt="image-20240708210659893" style="zoom:50%;" />

```java
int i = 0;
int j = i + 1;
```

上述 java 代码翻译成字节码指令之后如下：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image%20(1).png" alt="image (1)" style="zoom:45%;" />

要理解这段字节码指令是如何执行的，我们需要先理解两块内存区域：操作数栈和局部变量表。

- **操作数栈** 是用来存放临时数据的内容，是一个栈式的结构，先进后出。

- **局部变量表** 是存放方法中的局部变量，包含方法的参数、方法中定义的局部变量，在编译期就已经可以确定方法有多少个局部变量。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708211413930.png" alt="image-20240708211413930" style="zoom:35%;" />

1、iconst_0：将常量0放入操作数栈。此时栈上只有0。

2、istore_1：会从操作数栈中，将栈顶的元素弹出来，此时0会被弹出，放入局部变量表的1号位置。局部变量表中的1号位置，在编译时就已经确定是局部变量i使用的位置。完成了对局部变量i的赋值操作。

3、iload_1：将局部变量表1号位置的数据放入操作数栈中，此时栈中会放入0。

4、iconst_1：会将常量1放入操作数栈中。

5、iadd：会将操作数栈顶部的两个数据相加，现在操作数栈上有两个数0和1，相加之后结果为1放入操作数栈中，此时栈上只有一个数也就是相加的结果1。

6、istore_2：从操作数栈中将1弹出，并放入局部变量表的2号位置，2号位置是j在使用。完成了对局部变量j的赋值操作。

7、return：语句执行，方法结束并返回。



### 属性

属性主要指的是类的属性，比如源码的文件名、内部类的列表等。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image%20(2).png" alt="image (2)" style="zoom:65%;" />



## 类的生命周期

类的生命周期描述了一个类加载、使用、卸载的整个过程。整体可以分为：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708211958605.png" alt="image-20240708211958605" style="zoom:35%;" />



### 加载阶段

1、加载(Loading) 阶段第一步是类加载器根据 **类的全限定名** 通过不同的渠道以二进制流的方式获取字节码信息。

程序员可以使用Java代码拓展的不同的渠道。



<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708212136747.png" alt="image-20240708212136747" style="zoom:40%;" />

2、类加载器在加载完类之后，Java 虚拟机会将字节码中的信息保存到方法区中。

生成一个 `InstanceKlass` 对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708212319107.png" alt="image-20240708212319107" style="zoom:35%;" />



3、同时，Java 虚拟机还会在堆中生成一份与方法区中数据类似的 `java.lang.Class` 对象。

作用是在 Java 代码中去获取类的信息以及存储静态字段的数据（JDK8及之后）。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708212800753.png" alt="image-20240708212800753" style="zoom:35%;" />

​	

对于开发者来说，只需要访问堆中的Class对象而不需要访问方法区中所有信息。

这样Java虚拟机就能很好地控制开发者访问数据的范围。



<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708213031190.png" alt="image-20240708213031190" style="zoom:40%;" />



### 连接阶段

连接阶段分为三个子阶段:

- 验证，验证内容是否满足《Java虚拟机规范》。
- 准备，给静态变量赋初值。
- 解析，将常量池中的符号引用替换成指向内存的直接引用。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708213216455.png" alt="image-20240708213216455" style="zoom:35%;" />



**①  验证**

- 验证的主要目的是检测 Java 字节码文件是否遵守了《Java虚拟机规范》中的约束。这个阶段一般不需要程序员参与。

- 主要包含如下四部分，具体详见《Java虚拟机规范》：

​		1，文件格式验证，比如文件是否以 `0xCAFEBABE` 开头，主次版本号是否满足当前Java虚拟机版本要求。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708213426110.png" alt="image-20240708213426110" style="zoom:45%;" />

​		2，元信息验证，例如类必须有父类（super不能为空）。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708213553804.png" alt="image-20240708213553804" style="zoom:70%;" />

​		3，验证程序执行指令的语义，比如方法内的指令执行中跳转到不正确的位置。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708213635806.png" alt="image-20240708213635806" style="zoom:50%;" />

​		4，符号引用验证，例如是否访问了其他类中 `private` 的方法等。

对版本号的验证，在JDK8的源码中如下：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/(null)" alt="img" style="zoom:30%;" />

编译文件的主版本号不能高于运行环境主版本号，如果主版本号相等，副版本号也不能超过。



**②  准备**

- 准备阶段为 静态变量（static）分配内存并设置初始值，而每一种基本数据类型和引用数据类型都有其初始值。

注意：本章涉及到的内存结构只讨论JDK8及之后的版本，8 之前的版本后续章节详述。



| 数据类型     | 初始值   |
| ------------ | -------- |
| int          | 0        |
| long         | 0L       |
| short        | 0        |
| char         | ‘\u0000’ |
| byte         | 0        |
| boolean      | false    |
| double       | 0.0      |
| 引用数据类型 | null     |

final 修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值。

如下例子中，变量加上 final 进行修饰，在准备阶段 value 值就直接变成1了，因为 final 修饰的变量后续不会发生值的变更。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708220813155.png" alt="image-20240708220813155" style="zoom:35%;" />



**③  解析**

- 解析阶段主要是将常量池中的符号引用替换为直接引用；
- 符号引用就是在字节码文件中使用编号来访问常量池中的内容。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708221113590.png" alt="image-20240708221113590" style="zoom:45%;" />

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708221152697.png" alt="image-20240708221152697" style="zoom:50%;" />



### 初始化阶段

- 初始化阶段会执行静态代码块中的代码，并为静态变量赋值。
- 初始化阶段会执行字节码文件中 `clinit` 部分的字节码指令。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240708223730969.png" alt="image-20240708223730969" style="zoom:40%;" />

<font color='red'>clinit 方法中的执行顺序与 Java 中编写的顺序是一致的。</font>



**以下几种方式会导致类的初始化：**  （添加 `-XX:+TraceClassLoading` 参数可以打印出加载并初始化的类）

- 访问一个类的静态变量或者静态方法，注意变量是`final`修饰的并且等号右边是常量不会触发初始化。
- 调用 `Class.forName(String className)`。 
- `new` 一个该类的对象时。
- 执行 `Main` 方法的当前类。



**常见例题：**

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709145107229.png" alt="image-20240709145107229" style="zoom:50%;" />

```java
0 getstatic #1 <java/lang/System.out : Ljava/io/PrintStream;>
3 ldc #9 <D>		// 从常量池中将字符串 D 加载到操作数栈中
5 invokevirtual #3 <java/io/PrintStream.println : (Ljava/lang/String;)V>	// 调用 println() 打印操作数栈上的内容
8 return
```

上述字节码指令的作用是 执行 `static 中的 System.out.println("D");` 方法



<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709145740397.png" alt="image-20240709145740397" style="zoom:45%;" />

综上：

执行 `main` 方法先初始化 `Test1` 的初始化方法，输出结果 DA；然后执行两次 `Test1` 的构造方法；最终输出为：DACBCB





- `clinit` 指令在特定情况下不会出现，比如：如下几种情况是不会进行初始化指令执行的。

1，无静态代码块且无静态变量赋值语句。

2，有静态变量的声明，但是没有赋值语句。

3，静态变量的定义使用 `final` 关键字，这类变量会在准备阶段直接进行初始化。





- 直接访问父类的静态变量，不会触发子类的初始化。

- 子类的初始化 `clinit` 调用之前，会先调用父类的 `clinit` 初始化方法。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709150840375.png" alt="image-20240709150840375" style="zoom:45%;" />



如果去掉 `new B02()`，情况如下：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709150957344.png" alt="image-20240709150957344" style="zoom:50%;" />



### 总结

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709152314086.png" alt="image-20240709152314086" style="zoom:40%;" />

几个要点：

1，静态变量的定义使用 `final` 关键字，这类变量会在准备阶段直接进行初始化（除非要执行方法）。

2，直接访问父类的静态变量，不会触发子类的初始化。

3，子类的初始化 `cinit` 调用之前，会先调用父类的 `cinit` 初始化方法。



添加 `-XX:+TraceClassLoading` 参数可以打印出加载并初始化的类。



## 类加载器

### 基本概念

类加载器（ClassLoader）是 Java 虚拟机提供给应用程序去实现获取类和接口字节码数据的技术，**类加载器只参与加载过程中的字节码获取并加载到内存这一部分**。



<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/(null)-20240709153834187.(null)" alt="img" style="zoom:60%;" />

类加载器会通过二进制流的方式获取到字节码文件的内容，接下来将获取到的数据交给 Java 虚拟机，虚拟机会在方法区和堆上生成对应的对象保存字节码信息。



### 类加载器的分类

类加载器分为两类，一类是 Java 代码中实现的，一类是 Java 虚拟机底层源码实现的。

- 虚拟机底层实现：源代码位于Java虚拟机的源码中，实现语言与虚拟机底层语言一致，比如Hotspot使用C++。主要目的是保证Java程序运行中基础类被正确地加载，比如java.lang.String，Java虚拟机需要确保其可靠性。
- JDK中默认提供或者自定义：JDK中默认提供了多种处理不同渠道的类加载器，程序员也可以自己根据需求定制，使用Java语言。所有 Java 中实现的类加载器都需要继承 ClassLoader 这个抽象类。



类加载器的设计 JDK8 和 8 之后的版本差别较大，首先来看 JDK8 及之前的版本，这些版本中默认的类加载器有如下几种：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/(null)-20240709154102187.(null)" alt="img" style="zoom:60%;" />

类加载器的详细信息可以通过 Arthas 的 classloader 命令查看：

`classloader` - 查看 classloader 的继承树，urls，类加载信息，使用 classloader 去 getResource

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/(null)-20240709154213341.(null)" alt="img" style="zoom:50%;" />

- BootstrapClassLoader 是启动类加载器，numberOfInstances是类加载器的数量只有1个，loadedCountTotal是加载类的数量1861个。
- ExtClassLoader 是扩展类加载器
- AppClassLoader 是应用程序类加载器



### 启动类加载器

- 启动类加载器（Bootstrap ClassLoader）是由Hotspot虚拟机提供的、使用C++编写的类加载器。
- 默认加载Java安装目录/jre/lib下的类文件，比如rt.jar，tools.jar，resources.jar等。



```java
/**
 * 启动程序类加载器案例
 */
public class BootstrapClassLoaderDemo {
    public static void main(String[] args) throws IOException {
        ClassLoader classLoader = String.class.getClassLoader();
        System.out.println(classLoader);

        System.in.read();
    }
}
```

这段代码通过String类获取到它的类加载器并且打印，结果是`null`。这是因为启动类加载器在JDK8中是由C++语言来编写的，在Java代码中去获取既不适合也不安全，所以才返回`null`。

在Arthas中可以通过`sc -d 类名`的方式查看加载这个类的类加载器详细的信息，比如：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/(null)-20240709154357111.(null)" alt="img" style="zoom:60%;" />



通过上图可以看到，`java.lang.String` 类的类加载器是空的，Hash值也是null。



**用户扩展基础 jar 包**

如果用户想扩展一些比较基础的jar包，让启动类加载器加载，有两种途径：

- **放入jre/lib下进行扩展**。不推荐，尽可能不要去更改JDK安装目录中的内容，会出现即时放进去由于文件名不匹配的问题也不会正常地被加载。
- **使用参数进行扩展。**推荐，使用 `-Xbootclasspath/a:jar包目录/jar包名`   进行扩展，参数中的/a代表新增。



### 扩展类加载器和应用程序类加载器

- 扩展类加载器和应用程序类加载器都是 `JDK` 中提供的、使用 `Java` 编写的类加载器。
- 它们的源码都位于 `sun.misc.Launcher` 中，是一个静态内部类。继承自 `URLClassLoader`。具备通过目录或者指定jar包将字节码文件加载到内存中。



**继承关系图如下：**

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/(null)-20240709154958983.(null)" alt="img" style="zoom:60%;" />

- `ClassLoader` 类定义了具体的行为模式，简单来说就是先从本地或者网络获得字节码信息，然后调用虚拟机底层的方法创建方法区和堆上的对象。这样的好处就是让子类只需要去实现如何获取字节码信息这部分代码。
- `SecureClassLoader` 提供了证书机制，提升了安全性。
- `URLClassLoader` 提供了根据 `URL` 获取目录下或者指定jar包进行加载，获取字节码的数据。
- 扩展类加载器和应用程序类加载器继承自 `URLClassLoader`，获得了上述的三种能力。



### 扩展类加载器

扩展类加载器（Extension Class Loader）是JDK中提供的、使用Java编写的类加载器。默认加载Java安装目录 `/jre/lib/ext` 下的类文件。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/(null)-20240709155128162.(null)" alt="img" style="zoom:50%;" />



如下代码会打印 `ScriptEnvironment` 类的类加载器。ScriptEnvironment 是 `nashorn` 框架中用来运行 `javascript` 语言代码的环境类，他位于 `nashorn.jar` 包中被扩展类加载器加载；

```Java
/**
 * 扩展类加载器
 */
public class ExtClassLoaderDemo {
    public static void main(String[] args) throws IOException {
        ClassLoader classLoader = ScriptEnvironment.class.getClassLoader();
        System.out.println(classLoader);
    }
}
```

打印结果如下：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/(null)-20240709155235886.(null)" alt="img" style="zoom:50%;" />

通过扩展类加载器去加载用户jar包：

- **放入/jre/lib/ext下进行扩展**。不推荐，尽可能不要去更改JDK安装目录中的内容。
- **使用参数进行扩展使用参数进行扩展**。推荐，使用 `-Djava.ext.dirs=jar` 包目录 进行扩展,这种方式会覆盖掉原始目录，可以用 `;(windows):(macos/linux)` 追加上原始目录。

如下图中：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/(null)-20240709155452381.(null)" alt="img" style="zoom:60%;" />

使用`引号`将整个地址包裹起来，这样路径中即便是有空格也不需要额外处理。路径中要包含原来 `ext` 文件夹，同时在最后加上扩展的路径。



### 应用程序加载器

应用程序类加载器会加载 `classpath` 下的类文件，默认加载的是项目中的类以及通过 maven 引入的第三方jar包中的类。

如下案例中，打印出`Student`和`FileUtils`的类加载器：

```Java
/**
 * 应用程序类加载器案例
 */
public class AppClassLoaderDemo {
    public static void main(String[] args) throws IOException, InterruptedException {
        //当前项目中创建的Student类
        Student student = new Student();
        ClassLoader classLoader = Student.class.getClassLoader();
        System.out.println(classLoader);

        //maven依赖中包含的类
        ClassLoader classLoader1 = FileUtils.class.getClassLoader();
        System.out.println(classLoader1);

        Thread.sleep(1000);
        System.in.read();

    }
}
```



输出结果如下：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/(null)-20240709160740508.(null)" alt="img" style="zoom:60%;" />

这两个类均由应用程序类加载器加载。

类加载器的加载路径可以通过 `classloader –c hash` 值 查看：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/(null)-20240709160808360.(null)" alt="img" style="zoom:45%;" />



### 双亲委派机制



双亲委派机制指的是：当一个类加载器接收到加载类的任务时，会 <font color='red'>自底向上查找是否加载过，再由顶向下进行加载 </font>。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/(null)-20240709162155374.(null)" alt="img" style="zoom:60%;" />

详细流程：

每个类加载器都有一个父类加载器。父类加载器的关系如下，启动类加载器没有父类加载器：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/(null)-20240709162216929.(null)" alt="img" style="zoom:65%;" />

在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器。



### 双亲委派机制的作用

- **保证类加载的安全性**。通过双亲委派机制避免恶意代码替换JDK中的核心类库，比如java.lang.String，确保核心类库的完整性和安全性。
- **避免重复加载**。双亲委派机制可以避免同一个类被多次加载。



**如何指定加载类的类加载器？**

在 `Java` 中如何使用代码的方式去主动加载一个类呢？

方式1：使用 `Class.forName` 方法，使用当前类的类加载器去加载指定的类。

方式2：获取到类加载器，通过类加载器的 `loadClass` 方法指定某个类加载器加载。



### 打破双亲委派机制

打破双亲委派机制历史上有三种方式，但本质上只有第一种算是真正的打破了双亲委派机制：

- **自定义类加载器并且重写 `loadClass` 方法**。Tomcat 通过这种方式实现应用之间类隔离。
- 线程上下文类加载器。利用上下文类加载器加载类，比如 JDBC 和 JNDI 等。
- Osgi 框架的类加载器。历史上 Osgi 框架实现了一套新的类加载器机制，允许同级之间委托进行类的加载，目前很少使用。



### 自定义类加载器

- 一个Tomcat程序中是可以运行多个Web应用的，如果这两个应用中出现了相同限定名的类，比如Servlet类，Tomcat要保证这两个类都能加载并且它们应该是不同的类。
- 如果不打破双亲委派机制，当应用类加载器加载 Web 应用1中的 MyServle t之后，Web应用2中相同限定名的MyServlet类就无法被加载了。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709164451668.png" alt="image-20240709164451668" style="zoom:45%;" />

- `Tomcat` 使用了自定义类加载器来实现应用之间类的隔离。

每一个应用会有一个独立的类加载器加载对应的类。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709164625330.png" alt="image-20240709164625330" style="zoom:40%;" />



- 先来分析ClassLoader的原理，ClassLoader中包含了4个核心方法。双亲委派机制的核心代码就位于loadClass方法中。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709164804092.png" alt="image-20240709164804092" style="zoom:40%;" />

打破双亲委派机制的核心就是将下边这一段代码重新实现。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709164846340.png" alt="image-20240709164846340" style="zoom:45%;" />



**自定义类加载器父类怎么是 AppClassLoader 呢？**

默认情况下自定义类加载器的父类加载器是应用程序类加载器：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709165031721.png" alt="image-20240709165031721" style="zoom:45%;" />



以Jdk8为例，`ClassLoader` 类中提供了构造方法设置 `parent` 的内容：

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/(null)-20240709165132662.(null)" alt="img" style="zoom:50%;" />

这个构造方法由另外一个构造方法调用，其中父类加载器由 `getSystemClassLoader` 方法设置，该方法返回的是AppClassLoader。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/(null)-20240709165138768.(null)" alt="img" style="zoom:50%;" />

<font color='red'>在同一个Java虚拟机中，只有相同类加载器 + 相同的类限定名才会被认为是同一个类。</font>



### 线程上下文类加载器

利用上下文类加载器加载类，比如JDBC和JNDI等。

我们来看下JDBC的案例：

- JDBC 中使用了 `DriverManager` 来管理项目中引入的不同数据库的驱动，比如 `mysql` 驱动、`oracle` 驱动。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709165528786.png" alt="image-20240709165528786" style="zoom:45%;" />

- `DriverManager` 类位于 `rt.jar` 包中，由启动类加载器加载。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709165627520.png" alt="image-20240709165627520" style="zoom:50%;" />



- 依赖中的 `mysql` 驱动对应的类，由应用程序类加载器来加载。



<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709165703858.png" alt="image-20240709165703858" style="zoom:50%;" />

- DriverManager 属于rt.jar是启动类加载器加载的。而用户jar包中的驱动需要由应用类加载器加载，这就违反了双亲委派机制。



<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709165813385.png" alt="image-20240709165813385" style="zoom:50%;" />



**DriverManager怎么知道jar包中要加载的驱动在哪儿？**

- `DriverManage` 使用SPI机制，最终加载 `jar` 包中对应的驱动类。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709165956989.png" alt="image-20240709165956989" style="zoom:45%;" />



SPI中使用了线程上下文中保存的类加载器进行类的加载，这个类加载器一般是应用程序类加载器。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709170027812.png" alt="image-20240709170027812" style="zoom:40%;" />



**总结：**

1、启动类加载器加载 `DriverManager`。

2、在初始化 `DriverManager` 时，通过SPI机制加载jar包中的myql驱动。

3、SPI中利用了线程上下文类加载器（应用程序类加载器）去加载类并创建对象。

<font color='red'>这种由启动类加载器加载的类，委派应用程序类加载器去加载类的方式，打破了双亲委派机制。</font>

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709170315028.png" alt="image-20240709170315028" style="zoom:45%;" />



**DBC案例中真的打破了双亲委派机制吗？**

最早这个论点提出是在周志明《深入理解Java虚拟机》中，他认为打破了双亲委派机制，这种由启动类加载器加载的类，委派应用程序类加载器去加载类的方式，所以打破了双亲委派机制。

但是如果我们分别从DriverManager以及驱动类的加载流程上分析，JDBC只是在DriverManager加载完之后，通过初始化阶段触发了驱动类的加载，类的加载依然遵循双亲委派机制。

所以我认为这里没有打破双亲委派机制，只是用一种巧妙的方法让启动类加载器加载的类，去引发的其他类的加载。

### OSGi 模块化

- 历史上，OSGi模块化框架。它存在同级之间的类加载器的委托加载。OSGi还使用类加载器实现了热部署的功能。

- 热部署指的是在服务不停止的情况下，动态地更新字节码文件到内存中。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709170723629.png" alt="image-20240709170723629" style="zoom:40%;" />



### 不同 JDK 版本的类加载器

JDK8及之前的版本中，扩展类加载器和应用程序类加载器的源码位于rt.jar包中的sun.misc.Launcher.java。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709170955995-0516198.png" alt="image-20240709170955995" style="zoom:50%;" />



由于JDK9引入了module的概念，类加载器在设计上发生了很多变化。

1，启动类加载器使用Java编写，位于jdk.internal.loader.ClassLoaders类中。

   Java中的BootClassLoader继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件。

   启动类加载器依然无法通过java代码获取到，返回的仍然是null，保持了统一。



2，扩展类加载器被替换成了平台类加载器（Platform Class Loader）。

平台类加载器遵循模块化方式加载字节码文件，所以继承关系从URLClassLoader变成了BuiltinClassLoader，BuiltinClassLoader实现了从模块中加载字节码文件。

平台类加载器的存在更多的是为了与老版本的设计方案兼容，自身没有特殊的逻辑。

<img src="../media/2024-07-08-%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/image-20240709171149150.png" alt="image-20240709171149150" style="zoom:50%;" />

