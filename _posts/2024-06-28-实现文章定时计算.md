---
layout: post
title: 07 实现文章定时计算
date: 2024-06-28 10:27 +0800
categories: [Blogging,TJU-news]
author: <author_id>  
---

## 定时计算

<img src="../media/2024-06-28-%E5%AE%9E%E7%8E%B0%E6%96%87%E7%AB%A0%E5%AE%9A%E6%97%B6%E8%AE%A1%E7%AE%97/image-20240628110316443.png" alt="image-20240628110316443" style="zoom:40%;" />

- 根据文章的行为（点赞、评论、阅读、收藏）计算文章的分值，利用定时任务每天完成一次计算；

- 把分值较大的文章数据存入到 `redis` 中；

- `App` 端用户查询文章列表的时候，优先从 `redis` 中查询热度较高的文章数据。



### 定时任务框架 xxl-job

`spring` 传统的定时任务 `@Scheduled`，但是这样存在这一些问题 ：

- 做集群任务的重复执行问题；

- `cron` 表达式定义在代码之中，修改不方便；

- 定时任务失败了，无法重试也没有统计；

- 如果任务量过大，不能有效的分片执行；

解决这些问题的方案为：`xxl-job` 分布式任务调度框架。



## 热点文章定时计算

### 实现流程

- **需求分析：**

为每个频道缓存热度较高的 `30` 条文章优先展示；

判断文章热度较高的标准：**阅读**，**点赞**，**评论**，**收藏**



<img src="../media/2024-06-28-%E5%AE%9E%E7%8E%B0%E6%96%87%E7%AB%A0%E5%AE%9A%E6%97%B6%E8%AE%A1%E7%AE%97/image-20240620212554741.png" alt="image-20240620212554741" style="zoom:40%;" />

### 计算热点文章代码实现

**频道列表远程接口准备：**

计算完成新热数据后，需要给每个频道缓存一份数据，所以需要查询所有频道信息；

在 `TJU-campus-feign-api` 定义远程接口

```java
package com.shawen.apis.wemedia;

@FeignClient("leadnews-wemedia")
public interface IWemediaClient {

    @GetMapping("/api/v1/channel/list")
    public ResponseResult getChannels();
}
```

`TJU-campus-wemedia` 端提供接口

```java
package com.shawen.wemedia.feign;

@RestController
public class WemediaClient implements IWemediaClient {

    @Autowired
    private WmChannelService wmChannelService;

    @GetMapping("/api/v1/channel/list")
    @Override
    public ResponseResult getChannels() {
        return wmChannelService.findAll();
    }
}
```



- **Mapper** 

在 `ApArticleMapper` 中 新增方法，查询前5天的文章；

```java
    /**
     * 实现定时刷新
     * @param dayParam
     * @return
     */
    public List<ApArticle> findArticleListByLast5days(@Param("dayParam") Date dayParam);
```

在 `ApArticleMapper.xml` 对应地新增

```xml
<select id="findArticleListByLast5days" resultMap="resultMap">
    SELECT
    aa.*
    FROM
    `ap_article` aa
    LEFT JOIN ap_article_config aac ON aa.id = aac.article_id
    <where>
        and aac.is_delete != 1
        and aac.is_down != 1
        <if test="dayParam != null">
            and aa.publish_time <![CDATA[>=]]> #{dayParam}
        </if>
    </where>
</select>
```



- **Service  && Impl**

```java
package com.shawen.article.service;

public interface HotArticleService {

    /**
     * 计算热点文章
     */
    public void computeHotArticle();
}
```

修改 `ArticleConstans`，增加以下部分：

```java
public class ArticleConstants {

		......
  	public static final String ARTICLE_ES_SYNC_TOPIC = "article.es.sync.topic";

    public static final Integer HOT_ARTICLE_LIKE_WEIGHT = 3;
    public static final Integer HOT_ARTICLE_COMMENT_WEIGHT = 5;
    public static final Integer HOT_ARTICLE_COLLECTION_WEIGHT = 8;

    public static final String HOT_ARTICLE_FIRST_PAGE = "hot_article_first_page_";
}
```

创建一个 `vo` 接收计算分值后的对象：

```java
package com.shawen.model.article.vos;

@Data
public class HotArticleVo extends ApArticle {
    /**
     * 文章分值
     */
    private Integer score;
}
```

Impl

```java
@Service
@Slf4j
@Transactional
public class HotArticleServiceImpl implements HotArticleService {

    @Autowired
    private ApArticleMapper apArticleMapper;

    /**
     * 计算热点文章
     */
    @Override
    public void computeHotArticle() {
        //1.查询前5天的文章数据
        Date dateParam = DateTime.now().minusDays(50).toDate();
        List<ApArticle> apArticleList = apArticleMapper.findArticleListByLast5days(dateParam);

        //2.计算文章的分值
        List<HotArticleVo> hotArticleVoList = computeHotArticle(apArticleList);

        //3.为每个频道缓存30条分值较高的文章
        cacheTagToRedis(hotArticleVoList);

    }

    @Autowired
    private IWemediaClient wemediaClient;

    @Autowired
    private CacheService cacheService;

    /**
     * 为每个频道缓存30条分值较高的文章
     * @param hotArticleVoList
     */
    private void cacheTagToRedis(List<HotArticleVo> hotArticleVoList) {
        //每个频道缓存30条分值较高的文章
        ResponseResult responseResult = wemediaClient.getChannels();
        if(responseResult.getCode().equals(200)){
            String channelJson = JSON.toJSONString(responseResult.getData());
            List<WmChannel> wmChannels = JSON.parseArray(channelJson, WmChannel.class);
            //检索出每个频道的文章
            if(wmChannels != null && wmChannels.size() > 0){
                for (WmChannel wmChannel : wmChannels) {
                    List<HotArticleVo> hotArticleVos = hotArticleVoList.stream().filter(x -> x.getChannelId().equals(wmChannel.getId())).collect(Collectors.toList());
                    //给文章进行排序，取30条分值较高的文章存入redis  key：频道id   value：30条分值较高的文章
                    sortAndCache(hotArticleVos, ArticleConstants.HOT_ARTICLE_FIRST_PAGE + wmChannel.getId());
                }
            }
        }


        //设置推荐数据
        //给文章进行排序，取30条分值较高的文章存入redis  key：频道id   value：30条分值较高的文章
        sortAndCache(hotArticleVoList, ArticleConstants.HOT_ARTICLE_FIRST_PAGE+ArticleConstants.DEFAULT_TAG);


    }

    /**
     * 排序并且缓存数据
     * @param hotArticleVos
     * @param key
     */
    private void sortAndCache(List<HotArticleVo> hotArticleVos, String key) {
        hotArticleVos = hotArticleVos.stream().sorted(Comparator.comparing(HotArticleVo::getScore).reversed()).collect(Collectors.toList());
        if (hotArticleVos.size() > 30) {
            hotArticleVos = hotArticleVos.subList(0, 30);
        }
        cacheService.set(key, JSON.toJSONString(hotArticleVos));
    }

    /**
     * 计算文章分值
     * @param apArticleList
     * @return
     */
    private List<HotArticleVo> computeHotArticle(List<ApArticle> apArticleList) {

        List<HotArticleVo> hotArticleVoList = new ArrayList<>();

        if(apArticleList != null && apArticleList.size() > 0){
            for (ApArticle apArticle : apArticleList) {
                HotArticleVo hot = new HotArticleVo();
                BeanUtils.copyProperties(apArticle,hot);
                Integer score = computeScore(apArticle);
                hot.setScore(score);
                hotArticleVoList.add(hot);
            }
        }
        return hotArticleVoList;
    }

    /**
     * 计算文章的具体分值
     * @param apArticle
     * @return
     */
    private Integer computeScore(ApArticle apArticle) {
        Integer score = 0;
        if(apArticle.getLikes() != null){
            score += apArticle.getLikes() * ArticleConstants.HOT_ARTICLE_LIKE_WEIGHT;
        }
        if(apArticle.getViews() != null){
            score += apArticle.getViews();
        }
        if(apArticle.getComment() != null){
            score += apArticle.getComment() * ArticleConstants.HOT_ARTICLE_COMMENT_WEIGHT;
        }
        if(apArticle.getCollection() != null){
            score += apArticle.getCollection() * ArticleConstants.HOT_ARTICLE_COLLECTION_WEIGHT;
        }

        return score;
    }
}
```

在 `ArticleApplication` 的引导类中添加以下注解

```java
@EnableFeignClients(basePackages = "com.shawen.apis")
```

编写测试类，完成测试：

```java
@SpringBootTest(classes = ArticleApplication.class)
@RunWith(SpringRunner.class)
public class HotArticleServiceImplTest {

    @Autowired
    private HotArticleService hotArticleService;

    @Test
    public void computeHotArticle() {
        hotArticleService.computeHotArticle();
    }
}
```



### 定时功能

①：在 `TJU-campus-article` 中的pom文件中新增依赖

```xml
<!--xxl-job-->
<dependency>
    <groupId>com.xuxueli</groupId>
    <artifactId>xxl-job-core</artifactId>
    <version>2.3.0</version>
</dependency>
```

②： 在xxl-job-admin中新建执行器和任务

新建执行器：`leadnews-hot-article-executor` 

<img src="../media/2024-06-28-%E5%AE%9E%E7%8E%B0%E6%96%87%E7%AB%A0%E5%AE%9A%E6%97%B6%E8%AE%A1%E7%AE%97/image-20240628185705687.png" alt="image-20240628185705687" style="zoom:40%;" />

新建任务：路由策略为轮询，Cron表达式：0 0 2 * * ?  

<img src="../media/2024-06-28-%E5%AE%9E%E7%8E%B0%E6%96%87%E7%AB%A0%E5%AE%9A%E6%97%B6%E8%AE%A1%E7%AE%97/image-20240628185813100.png" alt="image-20240628185813100" style="zoom:35%;" />

③： `TJU-campus-article` 中集成 `xxl-job`

```java
@Configuration
public class XxlJobConfig {
    private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class);

    @Value("${xxl.job.admin.addresses}")
    private String adminAddresses;

    @Value("${xxl.job.executor.appname}")
    private String appname;

    @Value("${xxl.job.executor.port}")
    private int port;


    @Bean
    public XxlJobSpringExecutor xxlJobExecutor() {
        logger.info(">>>>>>>>>>> xxl-job config init.");
        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();
        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);
        xxlJobSpringExecutor.setAppname(appname);
        xxlJobSpringExecutor.setPort(port);
        return xxlJobSpringExecutor;
    }

}
```

在 `nacos` 配置新增配置

```yaml
xxl:
  job:
    admin:
      addresses: xxxx/xxl-job-admin
    executor:
      appname: leadnews-hot-article-executor
      port: 9999
```

④：在 `article` 微服务中新建任务类

```java
@Component
@Slf4j
public class ComputeHotArticleJob {

    @Autowired
    private HotArticleService hotArticleService;

    @XxlJob("computeHotArticleJob")
    public void handle(){
        log.info("热文章分值计算调度任务开始执行...");
        hotArticleService.computeHotArticle();
        log.info("热文章分值计算调度任务结束...");

    }
}
```



## 查询文章接口改造

### 流程展示

<img src="../media/2024-06-28-%E5%AE%9E%E7%8E%B0%E6%96%87%E7%AB%A0%E5%AE%9A%E6%97%B6%E8%AE%A1%E7%AE%97/image-20240628202407812.png" alt="image-20240628202407812" style="zoom:35%;" />

### 代码实现步骤

在 `ArticleHomeController` 中对原方法就行修改；

```
@PostMapping("/load")
public ResponseResult load(@RequestBody ArticleHomeDto dto){
    //        return apArticleService.load(dto, ArticleConstants.LOADTYPE_LOAD_MORE);
    return apArticleService.load2(dto, ArticleConstants.LOADTYPE_LOAD_MORE,true);
}
```

在 `ApArticleService` 中新增方法

```java
/**
     * 加载文章列表
     * @param dto
     * @param type  1 加载更多   2 加载最新
     * @param firstPage  true  是首页  flase 非首页
     * @return
     */
public ResponseResult load2(ArticleHomeDto dto,Short type,boolean firstPage);
```

`Impl` 对应实现

```java
    @Autowired
    private CacheService cacheService;

    /**
     * 加载文章列表
     * @param dto
     * @param type      1 加载更多   2 加载最新
     * @param firstPage true  是首页  flase 非首页
     * @return
     */
    @Override
    public ResponseResult load2(ArticleHomeDto dto, Short type, boolean firstPage) {
        if(firstPage){
            String jsonStr = cacheService.get(ArticleConstants.HOT_ARTICLE_FIRST_PAGE + dto.getTag());
            if(StringUtils.isNotBlank(jsonStr)){
                List<HotArticleVo> hotArticleVoList = JSON.parseArray(jsonStr, HotArticleVo.class);
                ResponseResult responseResult = ResponseResult.okResult(hotArticleVoList);
                return responseResult;
            }
        }
        return load(type,dto);
    }
```

