---
layout: post
title: 05 延迟任务精准发布文章
date: 2024-06-27 21:44 +0800
categories: [Blogging,TJU-news]
author: <author_id>  
---

## 延迟任务

### 概述

- **定时任务：**有固定周期的，有明确的触发时间
- **延迟队列：**没有固定的开始时间，它常常是由一个事件触发的，而在这个事件触发之后的一段时间内触发另一个事件，任务可以立即执行，也可以延迟



<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627215052397.png" alt="image-20240627215052397" style="zoom:40%;" />

**应用场景：**

场景一：订单下单之后 30 分钟后，如果用户没有付钱，则系统自动取消订单；如果期间下单成功，任务取消；

场景二：接口对接出现网络问题，1分钟后重试，如果失败，2分钟重试，直到出现阈值终止；



### 技术对比

- **DelayQueue**

`JDK` 自带 `DelayQueue` 是一个支持延时获取元素的阻塞队列， 内部采用优先队列 `PriorityQueue` 存储元素，同时元素必须实现 `Delayed` 接口；在创建元素时可以指定多久才可以从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627215353852.png" alt="image-20240627215353852" style="zoom:40%;" />

`DelayQueue` 属于排序队列，它的特殊之处在于队列的元素必须实现 `Delayed` 接口，该接口需要实现 `compareTo` 和 `getDelay` 方法；

`getDelay` 方法：获取元素在队列中的剩余时间，只有当剩余时间为 0 时元素才可以出队列。

`compareTo` 方法：用于排序，确定元素出队列的顺序。

使用 `DelayQueue` 作为延迟任务，如果程序挂掉之后，任务都是放在内存，消息会丢失。



- **RabbitMQ 实现延迟任务**

`TTL`：Time To Live (消息存活时间)；

`死信队列`：Dead Letter Exchange(死信交换机)，当消息成为 Dead message 后，可以重新发送另一个交换机（死信交换机）；

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627220530092.png" alt="image-20240627220530092" style="zoom:40%;" />

- **Redis 实现**

`zset` 数据类型的去重有序（分数排序）特点进行延迟。例如：时间戳作为 `score` 进行排序；

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627220853463.png" alt="image-20240627220853463" style="zoom:45%;" />

## Redis 实现延迟任务

### 执行流程

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627221042600.png" alt="image-20240627221042600" style="zoom:35%;" />

- **任务先添加到数据库**

**延迟任务是一个通用的服务**，任何需要延迟得任务都可以调用该服务，需要考虑数据持久化的问题，存储数据库中是一种数据安全的考虑。

- **Redis 中使用两种数据类型，list 和 zset**

效率问题，算法的时间复杂度

原因一：`list` 存储立即执行的任务，`zset` 存储未来的数据；

原因二：任务量过大以后，`zset` 的性能会下降；

时间复杂度：执行时间（次数）随着数据规模增长的变化趋势；

- 操作 `redis` 中的 `list` 命令 `LPUSH`：时间复杂度： `O(1)`；

- 操作 `redis` 中的 `zset` 命令 `zadd`：时间复杂度：`O(M*log(n))`；

|             |                    说明                    |
| :---------: | :----------------------------------------: |
|    O(1)     |  常量级复杂度，执行次数与数据规模没有关系  |
| O(M*log(n)) | 对数级复杂度，执行次数与数据规模是对数关系 |

- **在添加zset数据的时候，需要预加载**

任务模块是一个通用的模块，项目中任何需要延迟队列的地方，都可以调用这个接口，要考虑到数据量的问题，如果数据量特别大，为了防止阻塞，只需要把未来几分钟要执行的数据存入缓存即可。



### 搭建 `schedule` 模块

`TJU-campus-schedule`是一个通用的服务，单独创建模块来管理任何类型的延迟任务

①：在 `TJU-campus-service` 下创建 `TJU-campus-schedule`，如下图所示：

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627223008540.png" alt="image-20240627223008540" style="zoom:50%;" />

②：添加 `bootstrap.yml`

```yaml
server:
  port: 51701
spring:
  application:
    name: leadnews-schedule
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
      config:
        server-addr: localhost:8848
        file-extension: yml
```

③：在 `nacos` 中添加对应配置，并添加数据库及 `mybatis-plus` 的配置

```yaml
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql:localhost:3306/leadnews_schedule?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC&useSSL=false
    username: ****
    password: ****
# 设置Mapper接口所对应的XML文件位置，如果你在Mapper接口中有自定义方法，需要进行该配置
mybatis-plus:
  mapper-locations: classpath*:mapper/*.xml
  # 设置别名包扫描路径，通过该属性可以给包中的类注册别名
  type-aliases-package: com.shawen.model.schedule.pojos
```

### 表结构

`taskinfo` 任务表

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627223618488.png" alt="image-20240627223618488" style="zoom:40%;" />

**实体类：**

```java
@Data
@TableName("taskinfo")
public class Taskinfo implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 任务id
     */
    @TableId(type = IdType.ID_WORKER)
    private Long taskId;

    /**
     * 执行时间
     */
    @TableField("execute_time")
    private Date executeTime;

    /**
     * 参数
     */
    @TableField("parameters")
    private byte[] parameters;

    /**
     * 优先级
     */
    @TableField("priority")
    private Integer priority;

    /**
     * 任务类型
     */
    @TableField("task_type")
    private Integer taskType;


}
```

`taskinfo_logs` 任务日志表

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627223851089.png" alt="image-20240627223851089" style="zoom:45%;" />

实体类：

```java
@Data
@TableName("taskinfo_logs")
public class TaskinfoLogs implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 任务id
     */
    @TableId(type = IdType.ID_WORKER)
    private Long taskId;

    /**
     * 执行时间
     */
    @TableField("execute_time")
    private Date executeTime;

    /**
     * 参数
     */
    @TableField("parameters")
    private byte[] parameters;

    /**
     * 优先级
     */
    @TableField("priority")
    private Integer priority;

    /**
     * 任务类型
     */
    @TableField("task_type")
    private Integer taskType;

    /**
     * 版本号,用乐观锁
     */
    @Version
    private Integer version;

    /**
     * 状态 0=int 1=EXECUTED 2=CANCELLED
     */
    @TableField("status")
    private Integer status;


}
```

**乐观锁支持：**

```java
@SpringBootApplication
@MapperScan("com.heima.schedule.mapper")
public class ScheduleApplication {

    public static void main(String[] args) {
        SpringApplication.run(ScheduleApplication.class,args);
    }

    /**
     * mybatis-plus乐观锁支持
     * @return
     */
    @Bean
    public MybatisPlusInterceptor optimisticLockerInterceptor(){
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
        return interceptor;
    }
}
```



### 项目集成 Redis











