---
layout: post
title: 动态规划：从记忆化搜索到递推
date: 2024-07-03 14:21 +0800
categories: [算法分析,动态规划]
author: <author_id>  
---

## 动态规划入门：从记忆化搜索到递推

以 [198. 打家劫舍](https://leetcode.cn/problems/house-robber/) 为例，对动态规划进行分析。

<font color = 'red'>动态规划的核心是状态定义和状态转移方程。</font>

从子集型回溯中可以得到两种思路：**选或不选** 以及 **选哪个**；



### 记忆化搜索：递归搜索 + 保存计算结果

- **时间复杂度**:  O(n) ，其中 \( n \) 为 `nums` 的长度。

- **空间复杂度**:  O(n) 。

```java
class Solution {
    private int[] nums, memo;

    public int rob(int[] nums) {
        this.nums = nums;
        int n = nums.length;
        memo = new int[n];
        Arrays.fill(memo, -1); // -1 表示没有计算过
        return dfs(n - 1); // 从最后一个房子开始思考
    }

    // dfs(i) 表示从 nums[0] 到 nums[i] 最多能偷多少
    private int dfs(int i) {
        if (i < 0) { // 递归边界（没有房子）
            return 0;
        }
        if (memo[i] != -1) { // 之前计算过
            return memo[i];
        }
        int res = Math.max(dfs(i - 1), dfs(i - 2) + nums[i]);
        memo[i] = res; // 记忆化：保存计算结果
        return res;
    }
}
```



### 翻译成递推的逻辑

- **时间复杂度：**O(*n*)。其中 *n* 为 *nums* 的长度。
- **空间复杂度：**O(*n*)。

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        int[] f = new int[n + 2];
        for (int i = 0; i < n; i++) {
            f[i + 2] = Math.max(f[i + 1], f[i] + nums[i]);
        }
        return f[n + 1];
    }
}
```



### 空间优化

- **时间复杂度：**O(*n*)。其中 *n* 为 *nums* 的长度。
- **空间复杂度：**O(1)。仅用到若干额外变量。

```java
class Solution {
    public int rob(int[] nums) {
        int f0 = 0;
        int f1 = 0;
        for (int x : nums) {
            int newF = Math.max(f1, f0 + x);
            f0 = f1;
            f1 = newF;
        }
        return f1;
    }
}
```







