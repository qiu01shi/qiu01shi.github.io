---
layout: post
title: 05 延迟任务精准发布文章
date: 2024-06-27 21:44 +0800
categories: [Blogging,TJU-news]
author: <author_id>  
---

## 延迟任务

### 概述

- **定时任务：**有固定周期的，有明确的触发时间
- **延迟队列：**没有固定的开始时间，它常常是由一个事件触发的，而在这个事件触发之后的一段时间内触发另一个事件，任务可以立即执行，也可以延迟



<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627215052397.png" alt="image-20240627215052397" style="zoom:40%;" />

**应用场景：**

场景一：订单下单之后 30 分钟后，如果用户没有付钱，则系统自动取消订单；如果期间下单成功，任务取消；

场景二：接口对接出现网络问题，1分钟后重试，如果失败，2分钟重试，直到出现阈值终止；



### 技术对比

- **DelayQueue**

`JDK` 自带 `DelayQueue` 是一个支持延时获取元素的阻塞队列， 内部采用优先队列 `PriorityQueue` 存储元素，同时元素必须实现 `Delayed` 接口；在创建元素时可以指定多久才可以从队列中获取当前元素，只有在延迟期满时才能从队列中提取元素

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627215353852.png" alt="image-20240627215353852" style="zoom:40%;" />

`DelayQueue` 属于排序队列，它的特殊之处在于队列的元素必须实现 `Delayed` 接口，该接口需要实现 `compareTo` 和 `getDelay` 方法；

`getDelay` 方法：获取元素在队列中的剩余时间，只有当剩余时间为 0 时元素才可以出队列。

`compareTo` 方法：用于排序，确定元素出队列的顺序。

使用 `DelayQueue` 作为延迟任务，如果程序挂掉之后，任务都是放在内存，消息会丢失。



- **RabbitMQ 实现延迟任务**

`TTL`：Time To Live (消息存活时间)；

`死信队列`：Dead Letter Exchange(死信交换机)，当消息成为 Dead message 后，可以重新发送另一个交换机（死信交换机）；

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627220530092.png" alt="image-20240627220530092" style="zoom:40%;" />

- **Redis 实现**

`zset` 数据类型的去重有序（分数排序）特点进行延迟。例如：时间戳作为 `score` 进行排序；

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627220853463.png" alt="image-20240627220853463" style="zoom:45%;" />

## Redis 实现延迟任务

### 执行流程

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627221042600.png" alt="image-20240627221042600" style="zoom:35%;" />

- **任务先添加到数据库**

**延迟任务是一个通用的服务**，任何需要延迟得任务都可以调用该服务，需要考虑数据持久化的问题，存储数据库中是一种数据安全的考虑。

- **Redis 中使用两种数据类型，list 和 zset**

效率问题，算法的时间复杂度

原因一：`list` 存储立即执行的任务，`zset` 存储未来的数据；

原因二：任务量过大以后，`zset` 的性能会下降；

时间复杂度：执行时间（次数）随着数据规模增长的变化趋势；

- 操作 `redis` 中的 `list` 命令 `LPUSH`：时间复杂度： `O(1)`；

- 操作 `redis` 中的 `zset` 命令 `zadd`：时间复杂度：`O(M*log(n))`；

|             |                    说明                    |
| :---------: | :----------------------------------------: |
|    O(1)     |  常量级复杂度，执行次数与数据规模没有关系  |
| O(M*log(n)) | 对数级复杂度，执行次数与数据规模是对数关系 |

- **在添加zset数据的时候，需要预加载**

任务模块是一个通用的模块，项目中任何需要延迟队列的地方，都可以调用这个接口，要考虑到数据量的问题，如果数据量特别大，为了防止阻塞，只需要把未来几分钟要执行的数据存入缓存即可。



### 搭建 `schedule` 模块

`TJU-campus-schedule`是一个通用的服务，单独创建模块来管理任何类型的延迟任务

①：在 `TJU-campus-service` 下创建 `TJU-campus-schedule`，如下图所示：

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627223008540.png" alt="image-20240627223008540" style="zoom:50%;" />

②：添加 `bootstrap.yml`

```yaml
server:
  port: 51701
spring:
  application:
    name: leadnews-schedule
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
      config:
        server-addr: localhost:8848
        file-extension: yml
```

③：在 `nacos` 中添加对应配置，并添加数据库及 `mybatis-plus` 的配置

```yaml
spring:
  datasource:
    driver-class-name: com.mysql.jdbc.Driver
    url: jdbc:mysql:localhost:3306/leadnews_schedule?useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC&useSSL=false
    username: ****
    password: ****
# 设置Mapper接口所对应的XML文件位置，如果你在Mapper接口中有自定义方法，需要进行该配置
mybatis-plus:
  mapper-locations: classpath*:mapper/*.xml
  # 设置别名包扫描路径，通过该属性可以给包中的类注册别名
  type-aliases-package: com.shawen.model.schedule.pojos
```

### 表结构

`taskinfo` 任务表

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627223618488.png" alt="image-20240627223618488" style="zoom:40%;" />

**实体类：**

```java
@Data
@TableName("taskinfo")
public class Taskinfo implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 任务id
     */
    @TableId(type = IdType.ID_WORKER)
    private Long taskId;

    /**
     * 执行时间
     */
    @TableField("execute_time")
    private Date executeTime;

    /**
     * 参数
     */
    @TableField("parameters")
    private byte[] parameters;

    /**
     * 优先级
     */
    @TableField("priority")
    private Integer priority;

    /**
     * 任务类型
     */
    @TableField("task_type")
    private Integer taskType;


}
```

`taskinfo_logs` 任务日志表

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627223851089.png" alt="image-20240627223851089" style="zoom:45%;" />

实体类：

```java
@Data
@TableName("taskinfo_logs")
public class TaskinfoLogs implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 任务id
     */
    @TableId(type = IdType.ID_WORKER)
    private Long taskId;

    /**
     * 执行时间
     */
    @TableField("execute_time")
    private Date executeTime;

    /**
     * 参数
     */
    @TableField("parameters")
    private byte[] parameters;

    /**
     * 优先级
     */
    @TableField("priority")
    private Integer priority;

    /**
     * 任务类型
     */
    @TableField("task_type")
    private Integer taskType;

    /**
     * 版本号,用乐观锁
     */
    @Version
    private Integer version;

    /**
     * 状态 0=int 1=EXECUTED 2=CANCELLED
     */
    @TableField("status")
    private Integer status;


}
```

**乐观锁支持：**

```java
@SpringBootApplication
@MapperScan("com.heima.schedule.mapper")
public class ScheduleApplication {

    public static void main(String[] args) {
        SpringApplication.run(ScheduleApplication.class,args);
    }

    /**
     * mybatis-plus乐观锁支持
     * @return
     */
    @Bean
    public MybatisPlusInterceptor optimisticLockerInterceptor(){
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());
        return interceptor;
    }
}
```



### 项目集成 Redis

① 在 `common`项目导入redis相关依赖，已完成；

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<!-- redis依赖commons-pool 这个依赖一定要添加 -->
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
</dependency>
```

② 在 `TJU-campus-schedule` 中集成`redis`，添加以下 `nacos` 配置，链接上 `redis`

```
spring:
  redis:
    host: URL
    password: ****
    port: **
```

③   创建 `CacheService` 类到 `TJU-campus-common` 模块下，并添加自动配置；

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240627225012569.png" alt="image-20240627225012569" style="zoom:35%;" />

### 添加任务

①：拷贝 `mybatis-plus` 生成的文件，mapper

②：创建 `task` 类，用于接收添加任务的参数

```java
package com.shawen.model.schedule.dtos;

@Data
public class Task implements Serializable {

    /**
     * 任务id
     */
    private Long taskId;
    /**
     * 类型
     */
    private Integer taskType;

    /**
     * 优先级
     */
    private Integer priority;

    /**
     * 执行id
     */
    private long executeTime;

    /**
     * task参数
     */
    private byte[] parameters;

}
```

③：创建 TaskService

```java
public interface TaskService {

    /**
     * 添加任务
     * @param task   任务对象
     * @return       任务id
     */
    public long addTask(Task task) ;

}
```

Impl

```java
@Service
@Transactional
@Slf4j
public class TaskServiceImpl implements TaskService {
    /**
     * 添加延迟任务
     *
     * @param task
     * @return
     */
    @Override
    public long addTask(Task task) {
        //1.添加任务到数据库中

        boolean success = addTaskToDb(task);

        if (success) {
            //2.添加任务到redis
            addTaskToCache(task);
        }


        return task.getTaskId();
    }

    @Autowired
    private CacheService cacheService;

    /**
     * 把任务添加到redis中
     *
     * @param task
     */
    private void addTaskToCache(Task task) {

        String key = task.getTaskType() + "_" + task.getPriority();

        //获取5分钟之后的时间  毫秒值
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.MINUTE, 5);
        long nextScheduleTime = calendar.getTimeInMillis();

        //2.1 如果任务的执行时间小于等于当前时间，存入list
        if (task.getExecuteTime() <= System.currentTimeMillis()) {
            cacheService.lLeftPush(ScheduleConstants.TOPIC + key, JSON.toJSONString(task));
        } else if (task.getExecuteTime() <= nextScheduleTime) {
            //2.2 如果任务的执行时间大于当前时间 && 小于等于预设时间（未来5分钟） 存入zset中
            cacheService.zAdd(ScheduleConstants.FUTURE + key, JSON.toJSONString(task), task.getExecuteTime());
        }

    }

    @Autowired
    private TaskinfoMapper taskinfoMapper;

    @Autowired
    private TaskinfoLogsMapper taskinfoLogsMapper;

    /**
     * 添加任务到数据库中
     *
     * @param task
     * @return
     */
    private boolean addTaskToDb(Task task) {

        boolean flag = false;

        try {
            //保存任务表
            Taskinfo taskinfo = new Taskinfo();
            BeanUtils.copyProperties(task, taskinfo);
            taskinfo.setExecuteTime(new Date(task.getExecuteTime()));
            taskinfoMapper.insert(taskinfo);

            //设置taskID
            task.setTaskId(taskinfo.getTaskId());

            //保存任务日志数据
            TaskinfoLogs taskinfoLogs = new TaskinfoLogs();
            BeanUtils.copyProperties(taskinfo, taskinfoLogs);
            taskinfoLogs.setVersion(1);
            taskinfoLogs.setStatus(ScheduleConstants.SCHEDULED);
            taskinfoLogsMapper.insert(taskinfoLogs);

            flag = true;
        } catch (Exception e) {
            e.printStackTrace();
        }

        return flag;
    }
}
```

④：`ScheduleConstants` 常量类

```java
package com.shawen.common.constants;

public class ScheduleConstants {

    //task状态
    public static final int SCHEDULED=0;   //初始化状态

    public static final int EXECUTED=1;       //已执行状态

    public static final int CANCELLED=2;   //已取消状态

    public static String FUTURE="future_";   //未来数据key前缀

    public static String TOPIC="topic_";     //当前数据key前缀
}
```



### 取消任务

在 `TaskService` 中添加方法

```java
/**
     * 取消任务
     * @param taskId        任务id
     * @return              取消结果
     */
public boolean cancelTask(long taskId);
```

Impl

```java
		/**
     * 取消任务
     * @param taskId
     * @return
     */
    @Override
    public boolean cancelTask(long taskId) {

        boolean flag = false;

        //删除任务，更新日志
        Task task = updateDb(taskId,ScheduleConstants.CANCELLED);

        //删除redis的数据
        if(task != null){
            removeTaskFromCache(task);
            flag = true;
        }

        return flag;
    }

    /**
     * 删除redis中的任务数据
     * @param task
     */
    private void removeTaskFromCache(Task task) {

        String key = task.getTaskType()+"_"+task.getPriority();

        if(task.getExecuteTime()<=System.currentTimeMillis()){
            cacheService.lRemove(ScheduleConstants.TOPIC+key,0,JSON.toJSONString(task));
        }else {
            cacheService.zRemove(ScheduleConstants.FUTURE+key, JSON.toJSONString(task));
        }
    }

    /**
     * 删除任务，更新任务日志状态
     * @param taskId
     * @param status
     * @return
     */
    private Task updateDb(long taskId, int status) {
        Task task = null;
        try {
            // 删除任务
            taskinfoMapper.deleteById(taskId);

            // 更新任务日志
            TaskinfoLogs taskinfoLogs = taskinfoLogsMapper.selectById(taskId);
            taskinfoLogs.setStatus(status);
            taskinfoLogsMapper.updateById(taskinfoLogs);

            task = new Task();
            BeanUtils.copyProperties(taskinfoLogs,task);
            task.setExecuteTime(taskinfoLogs.getExecuteTime().getTime());
        }catch (Exception e){
            log.error("task cancel exception taskid={}",taskId);
        }

        return task;

    }
```

### 消费任务

在 `TaskService` 中添加方法

```java
    /**
     * 按照类型和优先级来拉取任务
     * @param type
     * @param priority
     * @return
     */
    public Task poll(int type,int priority);
```

Impl

```java
    /**
     * 按照类型和优先级拉取任务
     * @return
     */
    @Override
    public Task poll(int type,int priority) {
        Task task = null;
        try {
            String key = type+"_"+priority;
            String task_json = cacheService.lRightPop(ScheduleConstants.TOPIC + key);
            if(StringUtils.isNotBlank(task_json)){
                task = JSON.parseObject(task_json, Task.class);
                //更新数据库信息
                updateDb(task.getTaskId(),ScheduleConstants.EXECUTED);
            }
        }catch (Exception e){
            e.printStackTrace();
            log.error("poll task exception");
        }

        return task;
    }
```



### 未来数据定时刷新

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240628084730805.png" alt="image-20240628084730805" style="zoom:40%;" />

**获取Key 的方式对比：**

- 方案 1：keys 模糊匹配

`keys` 的模糊匹配功能很方便也很强大，但是在生产环境需要慎用！开发中使用 `keys` 的模糊匹配却发现 `redis` 的 `CPU` 使用率极高，所以公司的 `redis` 生产环境将 `keys` 命令禁用了！`redis` 是单线程，会被堵塞。

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240628084945474.png" alt="image-20240628084945474" style="zoom:50%;" />

- 方案 2：scan

`SCAN` 命令是一个基于游标的迭代器，`SCAN` 命令每次被调用之后， 都会向用户返回一个新的游标， 用户在下次迭代时需要使用这个新游标作为 `SCAN` 命令的游标参数， 以此来延续之前的迭代过程。

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240628085056960.png" alt="image-20240628085056960" style="zoom:40%;" />



**数据同步方式：**

第一：从 `zset` 中查出数据，并删除

第二：把数据存入到 `list` 中



- 普通 `redis` 客户端和服务器交互模式



<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240628085257293.png" alt="image-20240628085257293" style="zoom:45%;" />

- `Pipeline` 请求模型

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240628085352142.png" alt="image-20240628085352142" style="zoom:50%;" />

- 官方测试结果数据对比

<img src="../media/2024-06-27-%E5%BB%B6%E8%BF%9F%E4%BB%BB%E5%8A%A1%E7%B2%BE%E5%87%86%E5%8F%91%E5%B8%83%E6%96%87%E7%AB%A0/image-20240628085417720.png" alt="image-20240628085417720" style="zoom:45%;" />



**代码实现：**

在 `TaskService` 中添加方法：

```java
public void refresh();
```

Impl

```java
    /**
     * 未来数据定时刷新，每分钟执行一次
     */
    @Scheduled(cron = "0 */1 * * * ?")
    public void refresh() {
        System.out.println(System.currentTimeMillis() / 1000 + "执行了定时任务");

        // 获取所有未来数据集合的key值
        Set<String> futureKeys = cacheService.scan(ScheduleConstants.FUTURE + "*");// future_*
        for (String futureKey : futureKeys) { // future_250_250

            // 获取当前数据的  key  topic
            String topicKey = ScheduleConstants.TOPIC + futureKey.split(ScheduleConstants.FUTURE)[1];
            //获取该组key下当前需要消费的任务数据
            Set<String> tasks = cacheService.zRangeByScore(futureKey, 0, System.currentTimeMillis());
            if (!tasks.isEmpty()) {
                //将这些任务数据添加到消费者队列中
                cacheService.refreshWithPipeline(futureKey, topicKey, tasks);
                System.out.println("成功的将" + futureKey + "下的当前需要执行的任务数据刷新到" + topicKey + "下");
            }
        }
    }
```

在引导类中添加开启任务调度注解：`@EnableScheduling`



### 分布式锁解决集群下的方法抢占执行











